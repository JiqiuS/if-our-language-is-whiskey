#+TITLE:       如果我们的语言是威士忌——函数式编程初窥
#+AUTHOR:      Xu Sheng
#+EMAIL:       xusheng0711@gmail.com
#+DATE:        2020-06-01

* 前言

  随着软件变得越来越复杂，好的架构也变得越来越重要。具有好的架构的软件易于编写、调试和测试，并且能够尽可能得复用已有的模块，
从而降低功能开发的代价。不同于面向对象，函数式编程试图从函数的角度来封装模块，拆解功能，构造软件。
本次分享将从Java8引入的“新”特性开始，通过Haskell这门函数式编程语言和Haxl这个库，
介绍函数式编程的一些特性：高阶函数、懒惰求值、不可变数据和函数式编程的一些概念：纯函数、副作用、函子、应用函子、单子。

** 费曼的彩虹

   #+begin_quote
   “你知道是谁最早解释彩虹的由来吗？”我问。
   “笛卡儿。”他轻声回答。过了一会，他直视着我，问道：“那你觉得彩虹的哪一个特色，让笛卡儿产生做数学分析的灵感？”
   “唔，其实彩虹是圆锥体的一段，当水滴被来自观察者后方的光线照射时，会呈现出弧状的光谱颜色。”
   “然后呢？”
   “我想他的灵感来自于他发现可以藉由思考单一的水滴，以及它的几何位置来分析这个问题。”
   “你忽略了这个现象有一个重要的特色。”他说。
   “好吧，我放弃。你认为是什么启发了他的理论？”
   “我会说他的灵感来自于他认为彩虹很美。”
   #+end_quote
   
   ——《费曼的彩虹:物理大师的最后24堂课》（Feynman's Rainbow: A Search for Beauty in Physics and in Life）

** Lambda

   #+ATTR_ORG: :width 800
   [[./imgs/lambda_rainbow.png]]


* Java函数式编程

  March 18, 2014
  
  Java Programming Language
  1. Lambda Expressions, a new language feature, has been introduced in this release. 
They enable you to treat functionality as a method argument, or code as data. 
Lambda expressions let you express instances of single-method interfaces (referred to as functional interfaces) more compactly.
  2. Method references provide easy-to-read lambda expressions for methods that already have a name.

  Collections
  1. Classes in the new java.util.stream package provide a Stream API to support functional-style operations on streams of elements. 
The Stream API is integrated into the Collections API, which enables bulk operations on collections, 
such as sequential or parallel map-reduce transformations.

** stream
   
*** Iterating through a List

    #+begin_src java
    void forEach(Consumer<? super T> action);
    #+end_src

    #+begin_src java
    final List<String> friends =
        Arrays.asList("Brian", "Nate", "Neal", "Raju", "Sara", "Scott");

    for(String name : friends) {
        System.out.println(name);
    }

    friends.forEach((final String name) -> System.out.println(name));

    friends.forEach((name) -> System.out.println(name));

    friends.forEach(name -> System.out.println(name));

    friends.forEach(System.out::println);
    #+end_src

*** Transforming a List

    #+begin_src java
    <R> Stream<R> map(Function<? super T, ? extends R> mapper);
    #+end_src
    
    #+begin_src java
    // 1
    final List<String> uppercaseNames = new ArrayList<String>();
    for(String name : friends) {
        uppercaseNames.add(name.toUpperCase());
    }
    System.out.println(uppercaseNames);

    // 2
    final List<String> uppercaseNames = new ArrayList<String>();
    friends.forEach(name -> uppercaseNames.add(name.toUpperCase()));
    System.out.println(uppercaseNames);

    // 3
    friends.stream()
        .map(name -> name.toUpperCase())
        .forEach(name -> System.out.print(name + " "));

    // 4
    friends.stream()
        .map(String::toUpperCase)
        .map(name -> name + " ")
        .forEach(System.out::println);
    #+end_src

*** Finding Elements

    #+begin_src java
    Stream<T> filter(Predicate<? super T> predicate);
    #+end_src
    
    #+begin_src java
    // 1
    final List<String> startsWithN = new ArrayList<String>();
    for(String name : friends) {
        if(name.startsWith("N")) {
            startsWithN.add(name);
        }
    }

    // 2
    final List<String> startsWithN = friends.stream()
        .filter(name -> name.startsWith("N")).collect(Collectors.toList());
    #+end_src

*** Reducing a Collection to a Single Value

    #+begin_src java
    U accumulator = identity;
    for (T t : listOfT) {
        U newAccumulator = accumulator(t, accumulator);
        accumulator = combiner(accumulator, newAccumulator);
    }

    T reduce(T identity, BinaryOperator<T> accumulator);
    Optional<T> reduce(BinaryOperator<T> accumulator);
    <U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner);
    #+end_src

    #+begin_src java
    System.out.println("Total number of characters in all names: " + friends.stream()
                       .mapToInt(name -> name.length()).sum());

    final Optional<String> aLongName = friends.stream()
        .reduce((name1, name2) ->
                name1.length() >= name2.length() ? name1 : name2);
    aLongName.ifPresent(name ->
                        System.out.println(String.format("A longest name: %s", name)));

    friends.stream().reduce(0, (total, name) -> name.length() + total, Integer::sum);
    #+end_src

** Optional

   假设我们要追溯克隆羊的实验，我们想知道羊的基因历史，我们提供了 =father=, =mother= 方法用来查找羊的双亲，
但是由于这些羊中有一些是克隆羊，所以这些羊不一定都有父母。

   #+begin_src java
   class Sheep {}

   public static Sheep father(Sheep sheep) {
       // ...
   }

   public static Sheep mother(Sheep sheep) {
       // ...
   }
   #+end_src


*** 现在要定义函数 =maternalGrandfather= ，找羊的外祖父。
    #+begin_src java
    public static Sheep maternalGrandfather(Sheep s) {
        Sheep m = mother(s);
        if (m != null) {
            return father(m);
        }
        return null
    }
    #+end_src

*** 现在定义函数 =mothersPaternalGrandfather= 找羊的曾外祖父(妈的爸的爸)
    #+begin_src java
    public static Sheep mothersPaternalGrandfather(Sheep s) {
        Sheep m = mother(s);
        if (m != null) {
            Sheep f = father(m);
            if (f != null) {
                return father(f);
            }
        }
        return null;
    }
    #+end_src

*** 定义函数曾曾曾..........外祖父？

    [[./imgs/if-hell.jpeg]]
   
*** 如果我们使用 =Optional=

    #+begin_src java
    public static Optional<Sheep> fatherOpt(Sheep sheep) {
        return Optional.ofNullable(father(sheep));
    }

    public static Optional<Sheep> motherOpt(Sheep sheep) {
        return Optional.ofNullable(mother(sheep));
    }
    #+end_src

*** 现在要定义函数 =maternalGrandfatherOpt= ，找羊的外祖父。
    #+begin_src java
    public static Optional<Sheep> maternalGrandfatherOpt(Sheep s) {
        return motherOpt(s).flatMap(OptionalSample::fatherOpt);
    }
    #+end_src

*** 现在定义函数 =mothersPaternalGrandfatherOpt= 找羊的曾外祖父(妈的爸的爸)
    #+begin_src java
    public static Optional<Sheep> mothersPaternalGrandfatherOpt(Sheep s) {
        return motherOpt(s)
            .flatMap(OptionalSample::fatherOpt)
            .flatMap(OptionalSample::fatherOpt);
    }
    #+end_src

*** 现在定义函数 =mothersFathersMothersFathersMotherOpt= 找羊的妈的爸的妈的爸的妈
    #+begin_src java
    public static Optional<Sheep> mothersFathersMothersFathersMotherOpt(Sheep s) {
        return motherOpt(s)
            .flatMap(OptionalSample::fatherOpt)
            .flatMap(OptionalSample::motherOpt)
            .flatMap(OptionalSample::fatherOpt)
            .flatMap(OptionalSample::motherOpt);
    }
    #+end_src

** Working with Resources

*** resource
    
    #+begin_src java
    FileWriterEAM.use("test.txt", writer -> writer.writeStuff("hello world!"));

    class FileWriterEAM {
        public static void use(
                               final String fileName,
                               final UseInstance<FileWriterEAM, IOException> block
                               ) throws IOException {
            final FileWriterEAM writerEAM = new FileWriterEAM(fileName);
            try {
                block.accept(writerEAM);
            } finally {
                writerEAM.close();
            }
        }

        private final FileWriter writer;
        private FileWriterEAM(final String fileName) throws IOException {
            writer = new FileWriter(fileName);
        }
        private void close() throws IOException {
            System.out.println("close called automatically...");
            writer.close(); }
        public void writeStuff(final String message) throws IOException {
            writer.write(message);
        }
    }
    #+end_src

*** lock

    #+begin_src java
    class Locker {
        public static void runLocked(Lock lock, Runnable block) {
            lock.lock();
            try {
                block.run();
            } finally {
                lock.unlock();
            }
        }
    }

    public void doOp1() {
        runLocked(lock, () -> {/*...critical code ... */});
    }
    #+end_src

** Optimizing Recursions

*** Tail-Call Optimization (TCO)

    #+begin_src c
    #include <stdio.h>

    int even(int n);
    int odd(int n);

    int even(int n) {
      if (n == 0) {
        return 1;
      }
      return odd(n - 1);
    }

    int odd(int n) {
      if (n == 0) {
        return 0;
      }
      return even(n - 1);
    }

    int main() {
      printf("%d", even(1000000));
    }
    #+end_src

    #+begin_src text
    gcc main.c && ./a.out
    [1]    79338 segmentation fault  ./a.out

    gcc -O2 main.c && ./a.out
    1
    #+end_src

    #+begin_src shell-script
    gcc -S -O2 main.c -o main_tco.s
    gcc -S main.c -o main_no_tco.s
    #+end_src
    
    #+ATTR_ORG: :width 800
    [[./imgs/Xnip2020-06-03_13-55-16.png]]

    #+begin_src c
    int even(int n) {
      if (n == 0) {
        return 1;
      }
     LBB0_2:
      if (n == 1) {
        return 0;
      }
      n-=2;
      if (n != 0) {
        goto LBB0_2;
      }
      return 1;
    }
    #+end_src

*** Java does not provide Tail-Call Optimization (TCO)

    #+begin_src java
    package org.xusheng.ioliw.tco;

    public class NoTCO {
        private static boolean even(int n) {
            if (n == 0) {
                return true;
            }
            return odd(n - 1);
        }

        private static boolean odd(int n) {
            if (n == 0) {
                return false;
            }
            return even(n - 1);
        }

        public static void main(String[] args) {
            System.out.println(even(100000));
        }
    }
    #+end_src

    #+begin_src text
    Exception in thread "main" java.lang.StackOverflowError
      at org.xusheng.ioliw.tco.NoTCO.odd(NoTCO.java:15)
      at org.xusheng.ioliw.tco.NoTCO.even(NoTCO.java:8)
      at org.xusheng.ioliw.tco.NoTCO.odd(NoTCO.java:15)
      at org.xusheng.ioliw.tco.NoTCO.even(NoTCO.java:8)
      at org.xusheng.ioliw.tco.NoTCO.odd(NoTCO.java:15)
    ...
    #+end_src
    
*** Trampolines
    
    [[./imgs/trampoline.png]]

    #+begin_src java
    package org.xusheng.ioliw.tco;

    import java.util.stream.Stream;

    import static org.xusheng.ioliw.tco.TailCalls.call;
    import static org.xusheng.ioliw.tco.TailCalls.done;

    public class Trampolines {
        private static TailCall<Boolean> evenRec(final int number) {
            if (number == 0) {
                return done(true);
            }
            return call(() -> oddRec(number - 1));
        }

        private static TailCall<Boolean> oddRec(final int number) {
            if (number == 0) {
                return done(false);
            }
            return call(() -> evenRec(number - 1));
        }

        private static boolean even(final int number) {
            return evenRec(number).invoke();
        }

        public static void main(String[] args) {
            System.out.println(even(100000));
        }
    }

    @FunctionalInterface
    interface TailCall<T> {

        TailCall<T> apply();

        default boolean isComplete() {
            return false;
        }

        default T result() {
            throw new Error("not implemented");
        }

        default T invoke() {
            return Stream.iterate(this, TailCall::apply)
                .filter(TailCall::isComplete)
                .findFirst()
                .get()
                .result();
        }
    }

    class TailCalls {
        public static <T> TailCall<T> call(final TailCall<T> nextCall) {
            return nextCall;
        }

        public static <T> TailCall<T> done(final T value) {
            return new TailCall<T>() {
                @Override
                public boolean isComplete() {
                    return true;
                }

                @Override
                public T result() {
                    return value;
                }

                @Override
                public TailCall<T> apply() {
                    throw new Error("not implemented");
                }
            };
        }
    }
    #+end_src


* Haskell函数式编程语言

  [[./imgs/haskell-logo.svg]]
  
  An advanced, purely functional programming language

** 关于Haskell的段子
*** how to learn Haskell

    #+ATTR_ORG: :width 800
    [[./imgs/howtolearnhaskell.png]]
   
*** learning curves for different programming languages

    [[./imgs/java.png]]
    [[./imgs/haskell.png]]

    [[https://github.com/Dobiasd/articles/blob/master/programming_language_learning_curves.md]]

*** code written in Haskell is guaranteed to have no side effects

    [[./imgs/haskell_2x.png]]

*** my own jokes
    
    我大概看了这本书十年

    Real Wrold Haskell
    
    [[./imgs/realworldhaskell.jpg]]


** pure function

   在程序设计中，若一个函数符合以下要求，则它可能被认为是纯函数：

   1. 此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关。
   2. 该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。

   #+begin_src haskell
   double :: Int -> Int
   double i = i + i
   #+end_src      
   
** immutable data

   #+begin_src haskell
   data Person = Person { firstName :: String
                        , lastName :: String
                        } deriving (Show)

   p1 = Person { firstName = "Shane", lastName = "Xu" }

   p2 = p1 { firstName = "Sheng" }
   #+end_src

** first-class function

   #+begin_src haskell
   plus :: Int -> Int -> Int
   plus a b = a + b

   plus1 :: Int -> Int
   plus1 = plus 1 -- Currying

   multiply :: Int -> Int -> Int
   multiply a b = a * b

   multiply2 = multiply 2

   plus1ThenMultiply2 = multiply2 . plus1

   map plus1ThenMultiply2 [1, 2, 3]

   map (\i -> ( i + 1) * 2) [1, 2, 3]
   #+end_src

** lazy

   #+begin_src haskell
   fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
   #+end_src

** handle side effect

   #+begin_src haskell
   hello :: String -> IO ()
   hello who = putStrLn ("Hello, " ++ who ++ "!")

   main :: IO ()
   main = hello "World"
   #+end_src

** Functor(函子), Applicative Functor(应用函子), Monad(单子)

*** Functor
    
    #+begin_src haskell
    class Functor f where
        fmap :: (a -> b) -> f a -> f b
    #+end_src

*** Applicative

    #+begin_src haskell
    class (Functor f) => Applicative f where
        pure  :: a -> f a
        (<*>) :: f (a -> b) -> f a -> f b'
    #+end_src

*** Monad
    
    #+begin_src haskell
    class Monad m where
        (>>=)  :: m a -> (a -> m b) -> m b
        (>>)   :: m a ->  m b       -> m b
        return ::   a               -> m a
        fail   :: String -> m a
    #+end_src

**** Optional

     #+begin_src haskell
     data Optional t = Some t | None deriving (Eq, Ord, Show)

     instance Functor Optional where
       fmap _ None = None
       fmap f (Some x)  = Some (f x)

     instance Applicative Optional where
       pure = Some
       None <*> a = None
       Some f <*> a = fmap f a

     instance Monad Optional where
       None >>= f = None
       Some x >>= f = f x
     #+end_src

**** Maybe is a Monad

     #+begin_src haskell
     Just 1
       >> return 2
       >>= \t -> return (t+1)
     #+end_src

**** >>=

     >>=操作符或者叫bind函数，其实就是flatMap。
     Haskell Maybe 就是 Java Optional 

**** IO is a Monad

     #+begin_src haskell
     putStrLn "Who are you?"
       >> getLine
       >>= \name -> putStrLn ("Hello, " ++ name ++ "!")
     #+end_src

     #+begin_src text
     Prelude> :{
     Prelude| :type putStrLn "Who are you?"
     Prelude|   >> getLine
     Prelude|   >>= \name -> putStrLn ("Hello, " ++ name ++ "!")
     Prelude| :}
     putStrLn "Who are you?"
       >> getLine
       >>= \name -> putStrLn ("Hello, " ++ name ++ "!")
       :: IO ()
     Prelude>
     #+end_src
     
**** Why Monad？

     1. Modularity 
        They allow computations to be composed from simpler computations and separate the combination strategy from the actual computations being performed.
     2. Flexibility
        They allow functional programs to be much more adaptable than equivalent programs written without monads. 
        This is because the monad distills the computational strategy into a single place instead of requiring it be distributed throughout the entire program.
     3. Isolation
        They can be used to create imperative-style computational structures which remain safely isolated from the main body of the functional program.
        This is useful for incorporating side-effects (such as I/O) and state (which violates referential transparency) into a pure functional language like Haskell.


* Haxl基于Monad的优雅的数据加载框架

  [[./imgs/haxl-logo.png]]
  
  Haxl is a Haskell library that simplifies access to remote data, such as databases or web-based services. Haxl can automatically

  1. batch multiple requests to the same data source,
  2. request data from multiple data sources concurrently,
  3. cache previous requests,
  4. memoize computations.
     
  [[http://simonmar.github.io/bib/papers/haxl-icfp14.pdf][There is no Fork: An Abstraction for Efficient, Concurrent, and Concise Data Access]]

** FunWithHaxl
   
   [[https://github.com/shanexu/FunWithHaxl]]

   #+begin_src shell
   stack setup
   stack run
   #+end_src

   #+begin_src haskell
   {-# LANGUAGE OverloadedStrings #-}

   module Main where

   import System.Environment
   import qualified HaxlBlog as H
   import qualified BlogDB as R

   defaultDB = "blog.sqlite"

   main :: IO ()
   main = do
     putStrLn "raw:"
     R.run (R.getPostIds >>= mapM R.getPostContent) >>= print
     putStrLn "haxl:"
     H.run (H.getPostIds >>= mapM H.getPostContent) >>= print
   #+end_src

   #+begin_src text
   raw:
   select postid from postinfo;
   select content from postcontent where postid = 1;
   select content from postcontent where postid = 2;
   select content from postcontent where postid = 3;
   select content from postcontent where postid = 4;
   select content from postcontent where postid = 5;
   select content from postcontent where postid = 6;
   select content from postcontent where postid = 7;
   select content from postcontent where postid = 8;
   select content from postcontent where postid = 9;
   select content from postcontent where postid = 10;
   select content from postcontent where postid = 11;
   select content from postcontent where postid = 12;
   ["example content 1","example content 2","example content 3","example content 4","example content 5","example content 6","example content 7","example content 8","example content 9","example content 10","example content 11","example content 12"]
   haxl:
   select postid from postinfo;
   select postid,content from postcontent where postid in (12,11,10,9,8,7,6,5,4,3,2,1);
   ["example content 1","example content 2","example content 3","example content 4","example content 5","example content 6","example content 7","example content 8","example content 9","example content 10","example content 11","example content 12"]
   #+end_src

** make a plain
   
   假设几个数据之间依赖关系如下：
   #+begin_src dot :exports results :file ./imgs/deps.png :cmdline -Kdot -Tpng :hidden
   digraph G {
     "A" -> "B"
     "A" -> "C"
     "B" -> "D"
     "B" -> "E"
     "C" -> "F"
     "C" -> "E"
   }
   #+end_src

   #+RESULTS:
   [[file:./imgs/deps.png]]

   一种资源获取/计算的执行计划可以如下：
   #+begin_src dot :exports results :file ./imgs/schedule.png :cmdline -Kdot -Tpng :hidden
   digraph G {
     rankdir="LR";
     node [shape=box];
     "D, E, F" -> "B, C" -> "A"
   }
   #+end_src

   #+RESULTS:
   [[file:./imgs/schedule.png]]

** scala fetch example

   [[./imgs/fetch-logo.svg]] FETCH
   [[https://github.com/47degrees/fetch]]

   #+begin_src scala
   package org.xusheng.ioliw

   import cats.data.NonEmptyList
   import cats.effect._
   import cats.instances.list._
   import cats.syntax.all._
   import fetch._

   object sample {
     type NodeName = String

     case class Node(name: NodeName)

     case class Dep(name: NodeName, deps: List[NodeName])

     def latency[F[_] : Concurrent](msg: String): F[Unit] =
       for {
         _ <- Sync[F].delay(println(s"--> [${Thread.currentThread.getId}] $msg"))
         _ <- Sync[F].delay(Thread.sleep(1000))
         _ <- Sync[F].delay(println(s"<-- [${Thread.currentThread.getId}] $msg"))
       } yield ()

     val nodeDatabase: Map[NodeName, Node] = Map(
       "A" -> Node("A"),
       "B" -> Node("B"),
       "C" -> Node("C"),
       "D" -> Node("D"),
       "E" -> Node("E"),
       "F" -> Node("F")
     )

     object Nodes extends Data[NodeName, Node] {
       def name = "Nodes"

       def source[F[_] : ConcurrentEffect]: DataSource[F, NodeName, Node] = new DataSource[F, NodeName, Node] {
         override def data = Nodes

         override def CF = ConcurrentEffect[F]

         override def fetch(id: NodeName): F[Option[Node]] =
           latency[F](s"One Node $id") >> CF.pure(nodeDatabase.get(id))


         // override def maxBatchSize: Option[Int] = Some(2)

         override def batchExecution: BatchExecution = InParallel

         override def batch(ids: NonEmptyList[NodeName]): F[Map[NodeName, Node]] =
           latency[F](s"Batch Nodes $ids") >> CF.pure(nodeDatabase.filterKeys(ids.toList.toSet))
       }
     }

     def getNode[F[_] : ConcurrentEffect](id: NodeName): Fetch[F, Node] =
       Fetch(id, Nodes.source)

     def getGraph[F[_] : ConcurrentEffect](id: NodeName, deps: Map[NodeName, List[NodeName]]): Fetch[F, Node] =
       for {
         _ <- deps.get(id).map {
           ids => ids.traverse(i => getGraph(i, deps))
         }.getOrElse(Fetch.pure[F, List[Node]](List.empty))
         n <- getNode(id)
       } yield n

     def main(args: Array[String]): Unit = {
       import java.util.concurrent._

       import scala.concurrent.ExecutionContext
       import scala.concurrent.duration._

       val executor = new ScheduledThreadPoolExecutor(4)
       val executionContext: ExecutionContext = ExecutionContext.fromExecutor(executor)

       implicit val timer: Timer[IO] = IO.timer(executionContext)
       implicit val cs: ContextShift[IO] = IO.contextShift(executionContext)


       val deps = Map(
         "A" -> List("B", "C"),
         "B" -> List("D", "E"),
         "C" -> List("E", "F"),
       )

       Fetch.run[IO](getGraph("A", deps)).unsafeRunTimed(10.seconds)

       executor.shutdown()
     }
   }
   #+end_src

   #+begin_src text
   --> [19] Batch Nodes NonEmptyList(D, E, F)
   <-- [19] Batch Nodes NonEmptyList(D, E, F)
   --> [21] Batch Nodes NonEmptyList(B, C)
   <-- [21] Batch Nodes NonEmptyList(B, C)
   --> [19] One Node A
   <-- [19] One Node A
   #+end_src

** algorithm in java

*** IO
    
**** 一个简单的实现

     #+begin_src java
     public class IO<T> {
         private final Supplier<T> value;

         private IO(Supplier<T> value) {
             this.value = value;
         }

         public static <T> IO<T> of(Supplier<T> value) {
             return new IO<>(value);
         }

         public static <T> IO<T> ret(T t) {
             return new IO<>(() -> t);
         }

         public static <A, B> IO<B> bind(IO<A> ma, Function<A, IO<B>> f) {
             return new IO<>(() -> f.apply(ma.value.get()).value.get());
         }
     }

     #+end_src

**** 写几个util

     #+begin_src java
     public static IO<Void> printf(PrintStream s, String format, Object... args) {
         return IO.of(() -> {
                 s.printf(format, args);
                 return null;
             });
     }

     public static IO<Void> printf(String format, Object... args) {
         return printf(System.out, format, args);
     }

     public static IO<String> readLine(InputStream s) {
         return IO.of(() -> new Scanner(s).nextLine());
     }

     public static IO<String> readLine() {
         return readLine(System.in);
     }
     #+end_src

**** 使用实例

     #+begin_src java
     public static void main(String[] args) {
         printf("What's your name? ")
             .bind(readLine()).bind(name -> printf("Hello, %s\n", name))
             .bind(printf("How old are you? "))
             .bind(readInt())
             .bind(age -> printf("You are %d years old.\n", age))
             .runIO();
     }
     #+end_src

**** 但是...

     #+begin_src java
     IO<Void> m = printf("function composition\n")
         .bind(printf("begin\n"));
     for (int i = 0; i < 10000; i++) {
         m = m.bind(IO.ret(1)).bind(IO.ret(null));
     }
     m = m.bind(printf("end\n"));
     m.runIO();
     #+end_src

     #+begin_src text
     Exception in thread "main" java.lang.StackOverflowError
       at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
       at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
       at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
       at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
       at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
       at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
       at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
       at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
       at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
       at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
     ...
     #+end_src

**** 还记得trampoline吗？
     
***** 定义trampoline interface

      #+begin_src java
      public interface Trampoline<A> {

          Trampoline<A> resume();

          default A runT() {
              Trampoline<A> t = this;
              while (!(t instanceof Done)) {
                  t = t.resume();
              }
              return ((Done<A>) t).result;
          }

          default <B> Trampoline<B> flatMap(Function<A, Trampoline<B>> f) {
              return new FlatMap<>(this, f);
          }

          default <B> Trampoline<B> map(Function<A, B> f) {
              return new FlatMap<>(this, a -> done(f.apply(a)));
          }

      }
      #+end_src

***** Done

      #+begin_src java
      @AllArgsConstructor
      class Done<A> implements Trampoline<A> {
          private final A result;

          @Override
          public Trampoline<A> resume() {
              return this;
          }
      }

      static <T> Trampoline<T> done(T t) {
          return new Done<>(t);
      }
      #+end_src

***** More

      #+begin_src java
      @AllArgsConstructor
      class More<A> implements Trampoline<A> {
          private final Supplier<Trampoline<A>> k;

          @Override
          public Trampoline<A> resume() {
              return k.get();
          }
      }

      static <T> Trampoline<T> more(Supplier<Trampoline<T>> k) {
          return new More<>(k);
      }
      #+end_src

***** FlatMap

      #+begin_src scala :hidden
      final def resume: Either [() => Trampoline[A], A] =
        this match {
          case Done(v) => Right(v)
          case More(k) => Left(k)
          case FlatMap(a, f) => a match {
            case Done(v) => f(v).resume
            case More(k) => Left(() =>
              FlatMap(k(), f))
            case FlatMap(b, g) =>
              (FlatMap(b, (x: Any) => FlatMap(g(x), f) ): Trampoline[A]).resume
          }
        }
      #+end_src
      
      #+begin_src java
      @AllArgsConstructor
      class FlatMap<B, A> implements Trampoline<A> {
          private final Trampoline<B> sub;
          private final Function<B, Trampoline<A>> k;

          @Override
          public Trampoline<A> resume() {
              if (sub instanceof Done) {
                  return k.apply(((Done<B>) sub).result);
              }
              if (sub instanceof More) {
                  return new FlatMap<>(((More<B>) sub).k.get(), k);
              }
              if (sub instanceof FlatMap) {
                  FlatMap<Object, B> s = (FlatMap<Object, B>) sub;
                  Trampoline<Object> b = s.sub;
                  Function<Object, Trampoline<B>> g = s.k;
                  return new FlatMap<>(b, x -> new FlatMap<>(g.apply(x), k));
              }
              throw new RuntimeException("unhandled sub type " + this.sub.getClass());
          }
      }

      static <B, A> Trampoline<A> flatMap(Trampoline<B> sub, Function<B, Trampoline<A>> k) {
          return new FlatMap<>(sub, k);
      }
      #+end_src

***** 实例
      
      #+begin_src java
      public static void main(String[] args) {
          more(() -> {
                  System.out.print("What's your name? ");
                  return done(null);
              })
              .flatMap(v -> done(new Scanner(System.in).nextLine()))
              .flatMap(name -> {
                      System.out.printf("Hello, %s!\n", name);
                      return done(null);
                  })
              .runT();
      }
      #+end_src

**** 使用Trampoline优化IO

     #+begin_src java
     public class IO<T> {
         private final Trampoline<T> value;

         private IO(Trampoline<T> value) {
             this.value = value;
         }

         private IO(Supplier<T> value) {
             this(more(() -> done(value.get())));
         }

         public static <T> IO<T> ret(T t) {
             return pure(t);
         }

         public static <T> IO<T> pure(T t) {
             return new IO<>(() -> t);
         }

         public static <A, B> IO<B> fmap(Function<A, B> f, IO<A> fa) {
             return new IO<>(fa.value.map(f));
         }

         public static <A, B> IO<B> bind(IO<A> ma, Function<A, IO<B>> func) {
             return new IO<>(ma.value.flatMap(x -> func.apply(x).value));
         }
         // ...
     }
     #+end_src

**** 再试一次

     #+begin_src java
     public static void main(String[] args) {
         IO<Void> m = printf("trampoline\n")
             .bind(printf("begin\n"));
         for (int i = 0; i < 10000; i++) {
             m = m.bind(IO.ret(0)).bind(IO.ret(null));
         }
         m = m.bind(printf("end\n"));
         m.runIO();
     }
     #+end_src

     #+begin_src text
     trampoline
     begin
     end
     #+end_src

*** Fetch
    
**** DataSource

     #+begin_src java
     public interface DataSource<ID, DATA> {
         DATA fetch(ID id);
         default Map<ID, DATA> batch(List<ID> ids) {
             return ids.stream().distinct().map(id -> Tuple.tuple(id, fetch(id))).collect(Collectors.toMap(Tuple2::v1, Tuple2::v2));
         }
     }
     #+end_src

**** Request & BlockedRequest

     #+begin_src haskell
     data BlockedRequest =
       forall a . BlockedRequest (Request a) (IORef (FetchStatus a))
     #+end_src

     #+begin_src java
     @AllArgsConstructor
     @EqualsAndHashCode
     @Getter
     public class Request<ID> {
         private final ID id;
     }

     @AllArgsConstructor
     @Getter
     public class BlockedRequest<ID, DATA> {
         private final Request<ID> request;
         private final IORef<FetchStatus<DATA>> ref;
     }
     #+end_src

**** FetchStatus

     #+begin_src haskell
     data FetchStatus a = NotFetched | FetchSuccess a
     #+end_src
     
     #+begin_src java
     public interface FetchStatus<A> {
         class NotFetched<A> implements FetchStatus<A> {}

         @AllArgsConstructor
         @Getter
         class FetchSuccess<A> implements FetchStatus<A> {
             private final A value;
         }
     }
     #+end_src

**** IORef

     #+begin_src java
     @AllArgsConstructor
     @NoArgsConstructor
     public class IORef<A> {
         private A value;

         public static <A> IO<IORef<A>> newIORef(A a) {
             return IO.ret(new IORef<>(a));
         }

         public static <A> IO<A> readIORef(IORef<A> ref) {
             return IO.of(() -> ref.value);
         }

         public static <A> IO<Void> writeIORef(IORef<A> ref, A a) {
             return IO.of(() -> {
                     ref.value = a;
                     return null;
                 });
         }
     }
     #+end_src

**** Result

     #+begin_src haskell
     data Result a
       = Done a
       | Blocked (Seq BlockedRequest) (Fetch a)
     #+end_src

     #+begin_src java
     public interface Result<A> {
         @AllArgsConstructor
         @Getter
         class Done<A> implements Result<A> {
             private final A value;
         }

         @AllArgsConstructor
         @Getter
         class Blocked<ID, R, A> implements Result<A> {
             private final List<BlockedRequest<ID, R>> requests;
             private final Fetch<A> fetch;
         }
     }
     #+end_src

**** Fetch

     Fetch只是一个简单的带有类型为IO<Result<A>>字段的类。

     #+begin_src haskell
     newtype Fetch a = Fetch { unFetch :: IO (Result a) }
     #+end_src
     
     #+begin_src java
     @AllArgsConstructor
     @Getter
     public class Fetch<A> {
         private final IO<Result<A>> unFetch;
     }
     #+end_src

***** pure/return
      
      #+begin_src java
      public static <A> Fetch<A> ret(A a) {
          return new Fetch<>(IO.ret(new Done<>(a)));
      }
      #+end_src

***** fmap
      
      先看Haskell代码
      #+begin_src haskell
      fmap f a = Fetch $ do
        a' <- a
        case a' of
          Done x -> Done (f x)
          Blocked br c -> Blocked br (fmap f c)
      #+end_src

      再看java代码
      #+begin_src java
      public static <ID, R, A, B> Fetch<B> fmap(Function<A, B> f, Fetch<A> x) {
          return new Fetch<>(IO.fmap(r -> {
                      if (r instanceof Done) {
                          return new Done<>(f.apply(((Done<A>) r).getValue()));
                      }
                      if (r instanceof Blocked) {
                          Blocked<ID, R, A> blocked = (Blocked<ID, R, A>) r;
                          return new Blocked<>(blocked.getRequests(), fmap(f, blocked.getFetch()));
                      }
                      throw new RuntimeException("unhandled type " + r.getClass());
                  }, x.unFetch));
      }
      #+end_src

***** bind
      
      先看Haskell代码
      #+begin_src haskell
      Fetch m >>= k = Fetch $ do
        r <- m
        case r of
          Done a -> unFetch (k a)
          Blocked br c -> return (Blocked br (c >>= k))
      #+end_src

      再看java代码
      #+begin_src java
      public static <ID, R, A, B> Fetch<B> bind(Fetch<A> m, Function<A, Fetch<B>> k) {
          return new Fetch<>(IO.bind(m.unFetch, r -> {
                      if (r instanceof Done) {
                          return k.apply(((Done<A>) r).getValue()).unFetch;
                      }
                      if (r instanceof Blocked) {
                          Blocked<ID, R, A> blocked = (Blocked<ID, R, A>) r;
                          List<BlockedRequest<ID, R>> br = blocked.getRequests();
                          Fetch<A> c = blocked.getFetch();
                          return IO.ret(new Blocked<>(br, Fetch.bind(c, k)));
                      }
                      throw new RuntimeException("unhandled type " + r.getClass());
                  }));
      }
      #+end_src

***** <*>,ap

      先看Haskell代码
      #+begin_src haskell
      Fetch f <*> Fetch x = Fetch $ do
        f' <- f
        x' <- x
        case (f', x') of
          (Done g,        Done y       ) -> return (Done (g y))
          (Done g,        Blocked br c ) -> return (Blocked br (g <$> c))
          (Blocked br c,  Done y       ) -> return (Blocked br (c <*> return y))
          (Blocked br1 c, Blocked br2 d) -> return (Blocked (br1 <> br2) (c <*> d))
      #+end_src

      再看java代码

      #+begin_src java
      public static <ID, R, A, B> Fetch<B> ap(Fetch<Function<A, B>> f, Fetch<A> x) {
          return new Fetch<>(IO.bind(f.unFetch, f_ -> IO.bind(x.unFetch, x_ -> {
              if (f_ instanceof Done && x_ instanceof Done) {
                  Function<A, B> g = ((Done<Function<A, B>>) f_).getValue();
                  A y = ((Done<A>) x_).getValue();
                  return IO.ret(new Done<>(g.apply(y)));
              }
              if (f_ instanceof Done && x_ instanceof Blocked) {
                  Function<A, B> g = ((Done<Function<A, B>>) f_).getValue();
                  Blocked<ID, R, A> blocked = (Blocked<ID, R, A>) x_;
                  List<BlockedRequest<ID, R>> br = blocked.getRequests();
                  Fetch<A> c = blocked.getFetch();
                  return IO.ret(new Blocked<>(br, fmap(g, c)));
              }
              if (f_ instanceof Blocked && x_ instanceof Done) {
                  Blocked<ID, R, Function<A, B>> blocked = (Blocked<ID, R, Function<A, B>>) f_;
                  List<BlockedRequest<ID, R>> br = blocked.getRequests();
                  Fetch<Function<A, B>> c = blocked.getFetch();
                  A y = ((Done<A>) x_).getValue();
                  return IO.ret(new Blocked<>(br, ap(c, ret(y))));
              }
              if (f_ instanceof Blocked && x_ instanceof Blocked) {
                  Blocked<ID, R, Function<A, B>> blocked1 = (Blocked<ID, R, Function<A, B>>) f_;
                  Blocked<ID, R, A> blocked2 = (Blocked<ID, R, A>) x_;
                  List<BlockedRequest<ID, R>> br1 = blocked1.getRequests();
                  Fetch<Function<A, B>> c = blocked1.getFetch();
                  List<BlockedRequest<ID, R>> br2 = blocked2.getRequests();
                  Fetch<A> d = blocked2.getFetch();
                  List<BlockedRequest<ID, R>> br = ListUtils.concat(br1, br2);
                  return IO.ret(new Blocked<>(br, ap(c, d)));
              }
              throw new RuntimeException("unhandled type (f_, x_) " + Tuple.tuple(f_.getClass(), x_.getClass()));
          })));
      }
      #+end_src
      
***** fetch, fetchData

      先看Haskell代码
      #+begin_src haskell
      fetch :: [BlockedRequest] -> IO ()

      runFetch :: Fetch a -> IO a
      runFetch (Fetch h) = do
        r <- h
        case r of
          Done a -> return a
          Blocked br cont -> do
            fetch (toList br)
            runFetch cont
      #+end_src

      再看java代码
      #+begin_src java
      // fetch remote resource
      public static <ID, R> IO<Void> fetch(List<BlockedRequest<ID, R>> brs, DataSource<ID, R> ds) {
          if (brs.isEmpty()) {
              return IO.ret(null);
          }

          if (brs.size() == 1) {
              BlockedRequest<ID, R> first = brs.get(0);
              return IO.bind(IO.of(() -> ds.fetch(first.getRequest().getId())), user -> IORef.writeIORef(first.getRef(), new FetchSuccess<>(user)));
          }

          return IO.bind(
                         IO.of(() -> ds.batch(brs.stream().map(BlockedRequest::getRequest).distinct().map(Request::getId).collect(Collectors.toList()))),
                         results -> IO.mapM_((BlockedRequest<ID, R> br) -> {
                                 Request<ID> r = br.getRequest();
                                 IORef<FetchStatus<R>> ref = br.getRef();
                                 return IORef.writeIORef(ref, new FetchSuccess<>(results.get(r.getId())));
                             }, brs)
                         );
      }

      public static <ID, R, A> IO<A> runFetch(Fetch<A> f, DataSource<ID, R> ds) {
          return IO.bind(f.getUnFetch(), r -> {
                  if (r instanceof Done) {
                      return IO.ret(((Done<A>) r).getValue());
                  }
                  if (r instanceof Blocked) {
                      Blocked<ID, R, A> blocked = (Blocked<ID, R, A>) r;
                      List<BlockedRequest<ID, R>> br = blocked.getRequests();
                      Fetch<A> cont = blocked.getFetch();
                      return IO.bind(fetch(br, ds), x -> runFetch(cont, ds));
                  }
                  throw new RuntimeException("unhandled type " + r.getClass());
              });
      }
      #+end_src

**** fetch a graph

     #+begin_src java
     public static Fetch<Node> getNode(String id) {
         return Fetch.dataFetch(new Request<>(id));
     }

     public static Fetch<Node> getGraph(String id, Map<String, List<String>> deps) {
         List<String> ids = deps.get(id);
         if (ids == null) {
             return getNode(id);
         }
         return Fetch.mapM(i -> getGraph(i, deps), ids).bind(getNode(id));
     }
     #+end_src

*** Main
    
    #+begin_src java
    public static void main(String[] args) {
        Map<String, List<String>> deps = ImmutableMap.of(
            "A", ImmutableList.of("B", "C"),
            "B", ImmutableList.of("D", "E"),
            "C", ImmutableList.of("E", "F")
        );

        IO.runIO(Fetch.runFetch(getGraph("A", deps), ds));
    }
    #+end_src

    #+begin_src text
    --> [1] Batch Nodes [D, E, F]
    <-- [1] Batch Nodes [D, E, F]
    --> [1] Batch Nodes [B, C]
    <-- [1] Batch Nodes [B, C]
    --> [1] One Node A
    <-- [1] One Node A
    #+end_src


* 参考文档

  1. Why Functional Programming Matters
     [[https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf]]
  2. All About Monads
     [[https://wiki.haskell.org/All_About_Monads]]
  3. Stackless Scala With Free Monads
     [[http://blog.higher-order.com/assets/trampolines.pdf]]
  4. There is no Fork: an Abstraction for Efficient, Concurrent, and Concise Data Access
     [[http://simonmar.github.io/bib/papers/haxl-icfp14.pdf]]
  5. Real World Haskell
     [[http://book.realworldhaskell.org/read/]]
  6. Category Theory for Programmers
     [[https://github.com/hmemcpy/milewski-ctfp-pdf]]


* 关于标题

  《如果我们的语言是威士忌》是村上春树的游记，他的文字带着我们走上他独特视线的异国之旅。
那异国的风土人情，远方香醇的威士忌，在他的笔下缓缓流出，流入读者心中，沁人心脾。

  [[file:./imgs/cover.jpg]]


* 仓库地址

  [[https://github.com/shanexu/if-our-language-is-whiskey]]


* Q & A


* THANKS
