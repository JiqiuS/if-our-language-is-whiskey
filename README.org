#+TITLE:       如果我们的语言是威士忌——函数式编程初窥
#+AUTHOR:      Xu Sheng
#+EMAIL:       sheng.xu@tongdun.net
#+DATE:        2020-06-01

* Java函数式编程

  March 18, 2014
  
  Java Programming Language
  1. Lambda Expressions, a new language feature, has been introduced in this release. 
They enable you to treat functionality as a method argument, or code as data. 
Lambda expressions let you express instances of single-method interfaces (referred to as functional interfaces) more compactly.
  2. Method references provide easy-to-read lambda expressions for methods that already have a name.

  Collections
  1. Classes in the new java.util.stream package provide a Stream API to support functional-style operations on streams of elements. 
The Stream API is integrated into the Collections API, which enables bulk operations on collections, 
such as sequential or parallel map-reduce transformations.

** stream
   
*** Iterating through a List

    #+begin_src java
    void forEach(Consumer<? super T> action);
    #+end_src

    #+begin_src java
    final List<String> friends =
        Arrays.asList("Brian", "Nate", "Neal", "Raju", "Sara", "Scott");

    for(String name : friends) {
        System.out.println(name);
    }

    friends.forEach((final String name) -> System.out.println(name));

    friends.forEach((name) -> System.out.println(name));

    friends.forEach(name -> System.out.println(name));

    friends.forEach(System.out::println);
    #+end_src

*** Transforming a List

    #+begin_src java
    <R> Stream<R> map(Function<? super T, ? extends R> mapper);
    #+end_src
    
    #+begin_src java
    // 1
    final List<String> uppercaseNames = new ArrayList<String>();
    for(String name : friends) {
        uppercaseNames.add(name.toUpperCase());
    }
    System.out.println(uppercaseNames);

    // 2
    final List<String> uppercaseNames = new ArrayList<String>();
    friends.forEach(name -> uppercaseNames.add(name.toUpperCase()));
    System.out.println(uppercaseNames);

    // 3
    friends.stream()
        .map(name -> name.toUpperCase())
        .forEach(name -> System.out.print(name + " "));

    // 4
    friends.stream()
        .map(String::toUpperCase)
        .map(name -> name + " ")
        .forEach(System.out::println);
    #+end_src

*** Finding Elements

    #+begin_src java
    Stream<T> filter(Predicate<? super T> predicate);
    #+end_src
    
    #+begin_src java
    // 1
    final List<String> startsWithN = new ArrayList<String>();
    for(String name : friends) {
        if(name.startsWith("N")) {
            startsWithN.add(name);
        }
    }

    // 2
    final List<String> startsWithN = friends.stream()
        .filter(name -> name.startsWith("N")).collect(Collectors.toList());
    #+end_src

*** Reducing a Collection to a Single Value

    #+begin_src java
    T reduce(T identity, BinaryOperator<T> accumulator);
    Optional<T> reduce(BinaryOperator<T> accumulator);
    <U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner);
    #+end_src

    #+begin_src java
    System.out.println("Total number of characters in all names: " + friends.stream()
                       .mapToInt(name -> name.length()).sum());

    final Optional<String> aLongName = friends.stream()
        .reduce((name1, name2) ->
                name1.length() >= name2.length() ? name1 : name2);
    aLongName.ifPresent(name ->
                        System.out.println(String.format("A longest name: %s", name)));

    friends.stream().reduce(0, (total, name) -> name.length() + total, Integer::sum);
    #+end_src

** Optional

   假设我们要追溯克隆羊的实验，我们想知道羊的基因历史，我们提供了 =father=, =mother= 方法用来查找羊的双亲，但是由于这些羊中有一些是克隆羊，所以这些羊不一定都有父母。

   #+begin_src java
   class Sheep {}

   public static Sheep father(Sheep sheep) {
       // ...
   }

   public static Sheep mother(Sheep sheep) {
       // ...
   }
   #+end_src


   现在要定义函数 =maternalGrandfather= ，找羊的外祖父。
   #+begin_src java
   public static Sheep maternalGrandfather(Sheep s) {
       Sheep m = mother(s);
       if (m != null) {
           return father(m);
       }
       return null
   }
   #+end_src

   现在定义函数 =mothersPaternalGrandfather= 找羊的曾外祖父(妈的爸的爸)
   #+begin_src java
   public static Sheep mothersPaternalGrandfather(Sheep s) {
       Sheep m = mother(s);
       if (m != null) {
           Sheep f = father(m);
           if (f != null) {
               return father(f);
           }
       }
       return null;
   }
   #+end_src

   定义函数曾曾曾..........外祖父？
   [[./imgs/if-hell.jpeg]]
   
   如果我们使用 =Optional=

   #+begin_src java
   public static Optional<Sheep> fatherOpt(Sheep sheep) {
       return Optional.ofNullable(father(sheep));
   }

   public static Optional<Sheep> motherOpt(Sheep sheep) {
       return Optional.ofNullable(mother(sheep));
   }
   #+end_src

   现在要定义函数 =maternalGrandfatherOpt= ，找羊的外祖父。
   #+begin_src java
   public static Optional<Sheep> maternalGrandfatherOpt(Sheep s) {
       return motherOpt(s).flatMap(OptionalSample::fatherOpt);
   }
   #+end_src

   现在定义函数 =mothersPaternalGrandfatherOpt= 找羊的曾外祖父(妈的爸的爸)
   #+begin_src java
   public static Optional<Sheep> mothersPaternalGrandfatherOpt(Sheep s) {
       return motherOpt(s)
           .flatMap(OptionalSample::fatherOpt)
           .flatMap(OptionalSample::fatherOpt);
   }
   #+end_src

   现在定义函数 =mothersFathersMothersFathersMotherOpt= 找羊的妈的爸的妈的爸的妈
   #+begin_src java
   public static Optional<Sheep> mothersFathersMothersFathersMotherOpt(Sheep s) {
       return motherOpt(s)
           .flatMap(OptionalSample::fatherOpt)
           .flatMap(OptionalSample::motherOpt)
           .flatMap(OptionalSample::fatherOpt)
           .flatMap(OptionalSample::motherOpt);
   }
   #+end_src

** Working with Resources

   resource

   #+begin_src java
   FileWriterEAM.use("test.txt", writer -> writer.writeStuff("hello world!"));

   class FileWriterEAM {
       public static void use(
                              final String fileName,
                              final UseInstance<FileWriterEAM, IOException> block
                              ) throws IOException {
           final FileWriterEAM writerEAM = new FileWriterEAM(fileName);
           try {
               block.accept(writerEAM);
           } finally {
               writerEAM.close();
           }
       }

       private final FileWriter writer;
       private FileWriterEAM(final String fileName) throws IOException {
           writer = new FileWriter(fileName);
       }
       private void close() throws IOException {
           System.out.println("close called automatically...");
           writer.close(); }
       public void writeStuff(final String message) throws IOException {
           writer.write(message);
       }
   }
   #+end_src

   lock
   #+begin_src java
   class Locker {
       public static void runLocked(Lock lock, Runnable block) {
           lock.lock();
           try {
               block.run();
           } finally {
               lock.unlock();
           }
       }
   }

   public void doOp1() {
       runLocked(lock, () -> {/*...critical code ... */});
   }
   #+end_src

** Optimizing Recursions

*** Tail-Call Optimization (TCO)

    #+begin_src c
    #include <stdio.h>

    int even(int n);
    int odd(int n);

    int even(int n) {
      if (n == 0) {
        return 1;
      }
      return odd(n - 1);
    }

    int odd(int n) {
      if (n == 0) {
        return 0;
      }
      return even(n - 1);
    }

    int main() {
      printf("%d", even(1000000));
    }
    #+end_src

    #+begin_src text
    gcc main.c && ./a.out
    [1]    79338 segmentation fault  ./a.out

    gcc -O2 main.c && ./a.out
    1
    #+end_src

    #+begin_src shell-script
    gcc -S -O2 main.c -o main_tco.s
    gcc -S main.c -o main_no_tco.s
    #+end_src
    
    #+ATTR_ORG: :width 800
    [[./imgs/Xnip2020-06-03_13-55-16.png]]

    #+begin_src c
    int even(int n) {
      if (n == 0) {
        return 1;
      }
     LBB0_2:
      if (n == 1) {
        return 0;
      }
      n-=2;
      if (n != 0) {
        goto LBB0_2;
      }
      return 1;
    }
    #+end_src

*** Java does not provide Tail-Call Optimization (TCO)

    #+begin_src java
    package org.xusheng.ioliw.tco;

    public class NoTCO {
        private static boolean even(int n) {
            if (n == 0) {
                return true;
            }
            return odd(n - 1);
        }

        private static boolean odd(int n) {
            if (n == 0) {
                return false;
            }
            return even(n - 1);
        }

        public static void main(String[] args) {
            System.out.println(even(100000));
        }
    }
    #+end_src

    #+begin_src text
    Exception in thread "main" java.lang.StackOverflowError
      at org.xusheng.ioliw.tco.NoTCO.odd(NoTCO.java:15)
      at org.xusheng.ioliw.tco.NoTCO.even(NoTCO.java:8)
      at org.xusheng.ioliw.tco.NoTCO.odd(NoTCO.java:15)
      at org.xusheng.ioliw.tco.NoTCO.even(NoTCO.java:8)
      at org.xusheng.ioliw.tco.NoTCO.odd(NoTCO.java:15)
    ...
    #+end_src
    
*** Trampolines

    #+begin_src java
    package org.xusheng.ioliw.tco;

    import java.util.stream.Stream;

    import static org.xusheng.ioliw.tco.TailCalls.call;
    import static org.xusheng.ioliw.tco.TailCalls.done;

    public class Trampolines {
        private static TailCall<Boolean> evenRec(final int number) {
            if (number == 0) {
                return done(true);
            }
            return call(() -> oddRec(number - 1));
        }

        private static TailCall<Boolean> oddRec(final int number) {
            if (number == 0) {
                return done(false);
            }
            return call(() -> evenRec(number - 1));
        }

        private static boolean even(final int number) {
            return evenRec(number).invoke();
        }

        public static void main(String[] args) {
            System.out.println(even(100000));
        }
    }

    @FunctionalInterface
    interface TailCall<T> {

        TailCall<T> apply();

        default boolean isComplete() {
            return false;
        }

        default T result() {
            throw new Error("not implemented");
        }

        default T invoke() {
            return Stream.iterate(this, TailCall::apply)
                .filter(TailCall::isComplete)
                .findFirst()
                .get()
                .result();
        }
    }

    class TailCalls {
        public static <T> TailCall<T> call(final TailCall<T> nextCall) {
            return nextCall;
        }

        public static <T> TailCall<T> done(final T value) {
            return new TailCall<T>() {
                @Override
                public boolean isComplete() {
                    return true;
                }

                @Override
                public T result() {
                    return value;
                }

                @Override
                public TailCall<T> apply() {
                    throw new Error("not implemented");
                }
            };
        }
    }
    #+end_src


* Haskell

  [[./imgs/haskell-logo.svg]]
  
  An advanced, purely functional programming language

** 关于Haskell的段子
*** how to learn Haskell

    #+ATTR_ORG: :width 800
    [[./imgs/howtolearnhaskell.png]]
   
*** learning curves for different programming languages

    [[./imgs/java.png]]
    [[./imgs/haskell.png]]

*** code written in Haskell is guaranteed to have no side effects

    [[./imgs/haskell_2x.png]]

*** my own jokes
    
    我大概看了这本书十年

    Real Wrold Haskell
    
    [[./imgs/rwh-200.jpg]]


** pure function
   在程序设计中，若一个函数符合以下要求，则它可能被认为是纯函数：

   1. 此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关。
   2. 该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。

   #+begin_src haskell
   double :: Int -> Int
   double i = i + i
   #+end_src      
   
** immutable data

   #+begin_src haskell
   data Person = Person { firstName :: String
                        , lastName :: String
                        } deriving (Show)

   p1 = Person { firstName = "Shane", lastName = "Xu" }

   p2 = p1 { firstName = "Sheng" }
   #+end_src

** first-class function

   #+begin_src haskell
   plus :: Int -> Int -> Int
   plus a b = a + b

   plus1 :: Int -> Int
   plus1 = plus 1

   map plus1 [1,2,3]
   #+end_src

** lazy

   #+begin_src haskell
   fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
   #+end_src

** handle side effect

   #+begin_src haskell
   hello :: String -> IO ()
   hello who = putStrLn ("Hello, " ++ who ++ "!")

   main :: IO ()
   main = hello "World"
   #+end_src

** Monad, Functor, Applicative

*** Applicative

    #+begin_src haskell
    class (Functor f) => Applicative f where
        pure  :: a -> f a
        (<*>) :: f (a -> b) -> f a -> f b'
    #+end_src

*** Functor
    
    #+begin_src haskell
    class Functor f where
        fmap :: (a -> b) -> f a -> f b
    #+end_src

*** Monad
    
    #+begin_src haskell
    class Monad m where
        (>>=)  :: m a -> (a -> m b) -> m b
        (>>)   :: m a ->  m b       -> m b
        return ::   a               -> m a
        fail   :: String -> m a
    #+end_src

**** Maybe is a Monad

     #+begin_src haskell
     Just 1
       >> return 2
       >>= \t -> return (t+1)
     #+end_src

**** IO is a Monad

     #+begin_src haskell
     putStrLn "Who are you?"
       >> getLine
       >>= \name -> putStrLn ("Hello, " ++ name ++ "!")
     #+end_src
     
* Haxl
  
  Haxl is a Haskell library that simplifies access to remote data, such as databases or web-based services. Haxl can automatically

  1. batch multiple requests to the same data source,
  2. request data from multiple data sources concurrently,
  3. cache previous requests,
  4. memoize computations.
     
  [[http://simonmar.github.io/bib/papers/haxl-icfp14.pdf][There is no Fork: An Abstraction for Efficient, Concurrent, and Concise Data Access]]

** make a plain
   
   #+begin_src dot :file ./imgs/deps.png :cmdline -Kdot -Tpng
   digraph G {
     "A" -> "B"
     "A" -> "C"
     "B" -> "D"
     "B" -> "E"
     "C" -> "F"
     "C" -> "E"
   }
   #+end_src

   #+RESULTS:
   [[file:./imgs/deps.png]]

   #+begin_src text
   [D, E, F] --> [B, C] --> A
   #+end_src

   #+begin_src text
   [D, E] -> [F] --> [B, C] --> A
   #+end_src

** scala fetch example

   #+begin_src scala
   package org.xusheng.ioliw

   import cats.data.NonEmptyList
   import cats.effect._
   import cats.instances.list._
   import cats.syntax.all._
   import fetch._

   object sample {
     type NodeName = String

     case class Node(name: NodeName)

     case class Dep(name: NodeName, deps: List[NodeName])

     def latency[F[_] : Concurrent](msg: String): F[Unit] =
       for {
         _ <- Sync[F].delay(println(s"--> [${Thread.currentThread.getId}] $msg"))
         _ <- Sync[F].delay(Thread.sleep(1000))
         _ <- Sync[F].delay(println(s"<-- [${Thread.currentThread.getId}] $msg"))
       } yield ()

     val nodeDatabase: Map[NodeName, Node] = Map(
       "A" -> Node("A"),
       "B" -> Node("B"),
       "C" -> Node("C"),
       "D" -> Node("D"),
       "E" -> Node("E"),
       "F" -> Node("F")
     )

     object Nodes extends Data[NodeName, Node] {
       def name = "Nodes"

       def source[F[_] : ConcurrentEffect]: DataSource[F, NodeName, Node] = new DataSource[F, NodeName, Node] {
         override def data = Nodes

         override def CF = ConcurrentEffect[F]

         override def fetch(id: NodeName): F[Option[Node]] =
           latency[F](s"One Node $id") >> CF.pure(nodeDatabase.get(id))


         override def maxBatchSize: Option[Int] = Some(2)

         override def batchExecution: BatchExecution = InParallel

         override def batch(ids: NonEmptyList[NodeName]): F[Map[NodeName, Node]] =
           latency[F](s"Batch Nodes $ids") >> CF.pure(nodeDatabase.filterKeys(ids.toList.toSet))
       }
     }

     def getNode[F[_] : ConcurrentEffect](id: NodeName): Fetch[F, Node] =
       Fetch(id, Nodes.source)

     def getGraph[F[_] : ConcurrentEffect](id: NodeName, deps: Map[NodeName, List[NodeName]]): Fetch[F, Node] =
       for {
         _ <- deps.get(id).map {
           ids => ids.traverse(i => getGraph(i, deps))
         }.getOrElse(Fetch.pure[F, List[Node]](List.empty))
         n <- getNode(id)
       } yield n

     def main(args: Array[String]): Unit = {
       import java.util.concurrent._

       import scala.concurrent.ExecutionContext
       import scala.concurrent.duration._

       val executor = new ScheduledThreadPoolExecutor(4)
       val executionContext: ExecutionContext = ExecutionContext.fromExecutor(executor)

       implicit val timer: Timer[IO] = IO.timer(executionContext)
       implicit val cs: ContextShift[IO] = IO.contextShift(executionContext)


       val deps = Map(
         "A" -> List("B", "C"),
         "B" -> List("D", "E"),
         "C" -> List("E", "F"),
       )

       Fetch.run[IO](getGraph("A", deps)).unsafeRunTimed(10.seconds)

       executor.shutdown()
     }
   }
   #+end_src

   #+begin_src text
   --> [20] Batch Nodes NonEmptyList(D, E)
   --> [21] Batch Nodes NonEmptyList(F)
   <-- [21] Batch Nodes NonEmptyList(F)
   <-- [20] Batch Nodes NonEmptyList(D, E)
   --> [21] Batch Nodes NonEmptyList(B, C)
   <-- [21] Batch Nodes NonEmptyList(B, C)
   --> [20] One Node A
   <-- [20] One Node A
   #+end_src

** algorithm in java

*** IO
    
    #+begin_src java
    public static void main(String[] args) {
        printf("what's your name? ")
            .bind(readLine()).bind(name -> printf("Hello, %s\n", name))
            .bind(printf("How old are you? "))
            .bind(readInt())
            .bind(age -> printf("You are %d years old.\n", age))
            .runIO();
    }
    #+end_src

*** Fetch

    #+begin_src java
    public static Fetch<Node> getNode(String id) {
        return Fetch.dataFetch(new Request<>(id));
    }

    public static Fetch<Node> getGraph(String id, Map<String, List<String>> deps) {
        List<String> ids = deps.get(id);
        if (ids == null) {
            return getNode(id);
        }
        return Fetch.mapM(i -> getGraph(i, deps), ids).bind(getNode(id));
    }
    #+end_src

*** Main
    
    #+begin_src java
    public static void main(String[] args) {
        Map<String, List<String>> deps = ImmutableMap.of(
            "A", ImmutableList.of("B", "C"),
            "B", ImmutableList.of("D", "E"),
            "C", ImmutableList.of("E", "F")
        );

        IO.runIO(Fetch.runFetch(getGraph("A", deps), ds));
    }
    #+end_src

* 关于标题

  村上春树这次推出的游记《如果我们的语言是威士忌》中，还配有他夫人阳子拍摄的彩色风景照片40幅，因为游记中所记述的地方都是两人共同游历的。
这些照片使村上春树的文字更增添了一分生动美妙的色彩。这对夫妻的搭配真可谓是“珠联壁合”。

  [[file:./imgs/cover.jpg]]

* Q & A

* THANKS
