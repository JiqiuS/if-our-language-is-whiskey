#+TITLE:       如果我们的语言是威士忌——函数式编程初窥
#+AUTHOR:      Xu Sheng
#+EMAIL:       sheng.xu@sumscope.com
#+DATE:        2020-09-12
#+OPTIONS:     toc:1 reveal_single_file:nil reveal_history:t reveal_width:1200 reveal_height:800

#+REVEAL_ROOT:              ./reveal.js-4.0.2
#+REVEAL_REVEAL_JS_VERSION: 4
#+REVEAL_THEME:             black
#+REVEAL_PLUGINS:           (highlight)
#+REVEAL_EXTRA_CSS:         ./presentation.css


* 前言

  * Java8引入的“新”特性
  * Haskell
  * 函数复合、高阶函数、懒惰求值、不可变数据
  * 纯函数、副作用、函子、应用函子、单子

** 费曼的彩虹

   #+begin_quote
   “那你觉得彩虹的哪一个特色，让笛卡儿产生做数学分析的灵感？” \\
   “其实彩虹是圆锥体的一段，当水滴被来自观察者后方的光线照射时，会呈现出弧状的光谱颜色。我想他的灵感来自于他发现可以藉由思考单一的水滴，以及它的几何位置来分析这个问题。”\\
   #+end_quote

   #+REVEAL: split

   #+begin_quote
   “我会说他的灵感来自于他认为彩虹很美。”\\

   《费曼的彩虹:物理大师的最后24堂课》
   #+end_quote

   
** Lambda
   
   #+ATTR_ORG: :width 800
   #+ATTR_HTML: :style width: 70%;
   [[./imgs/lambda_rainbow.png]]

* Java函数式编程

  #+begin_quote
  March 18, 2014
  #+end_quote

  #+REVEAL: split

  #+begin_quote
  Java Programming Language

  1. Lambda Expressions, a new language feature, has been introduced in this release. 
  2. Method references provide easy-to-read lambda expressions for methods that already have a name.
  #+end_quote

  #+REVEAL: split

  #+begin_quote
  Collections
  
  1. Classes in the new java.util.stream package provide a Stream API to support functional-style operations on streams of elements. 
  #+end_quote

** stream

*** Iterating through a List

    #+begin_src java
    for(T t : listOfT) {
        // do something
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    void forEach(Consumer<? super T> action);
    #+end_src

    #+REVEAL: split

    #+begin_src java
    final List<String> friends =
        Arrays.asList("Brian", "Nate", "Neal", "Raju", "Sara", "Scott");

    for(String name : friends) {
        System.out.println(name);
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    friends.forEach((final String name) -> System.out.println(name));
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    friends.forEach((name) -> System.out.println(name));
    #+end_src

    #+ATTR_REVEAL: :frag frag-style    
    #+begin_src java
    friends.forEach(name -> System.out.println(name));
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    friends.forEach(System.out::println);
    #+end_src

*** Transforming a List
    
    #+begin_src java
    List<R> listOfR = new ArrayList<>();
    for(T t : listOfT) {
        R r = map(t);
        listOfR.put(r);
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    <R> Stream<R> map(Function<? super T, ? extends R> mapper);
    #+end_src

    #+REVEAL: split

    #+begin_src java
    final List<String> uppercaseNames = new ArrayList<String>();
    for(String name : friends) {
        uppercaseNames.add(name.toUpperCase());
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    final List<String> uppercaseNames = new ArrayList<String>();
    friends.forEach(name -> uppercaseNames.add(name.toUpperCase()));
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    friends.stream().map(name -> name.toUpperCase());
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    friends.stream().map(String::toUpperCase);
    #+end_src

*** Finding Elements

    #+begin_src java
    List filteredListOfT = new LinkedList<>();
    for(T t : listOfT) {
        if (predicate(t)) {
            filteredListOfT.add(t);
        }
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    Stream<T> filter(Predicate<? super T> predicate);
    #+end_src

    #+REVEAL: split

    #+begin_src java
    final List<String> startsWithN = new ArrayList<String>();
    for(String name : friends) {
        if(name.startsWith("N")) {
            startsWithN.add(name);
        }
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    final List<String> startsWithN = friends.stream()
        .filter(name -> name.startsWith("N")).collect(Collectors.toList());
    #+end_src

*** Reducing a Collection to a Single Value

    #+begin_src java
    T result = null;
    for (int i = 0; i < listOfT.size(); i++) {
        T t = listOfT.get(i);
        if (i == 0) {
            result = t;
            continue;
        }
        result = accumulator(t, result);
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    Optional<T> reduce(BinaryOperator<T> accumulator);
    #+end_src

    #+REVEAL: split

    #+begin_src java
    T result = identity;
    for (T t : listOfT) {
        result = accumulator(t, result);
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    T reduce(T identity, BinaryOperator<T> accumulator);
    #+end_src
    
    #+REVEAL: split

    #+begin_src java
    U result = identity;
    for (T t : listOfT) {
        U partialResult = accumulator(t, result);
        result = combiner(result, partialResult);
    }
    #+end_src
    
    #+ATTR_REVEAL: :frag t
    #+begin_src java
    <U> U reduce(U identity,
                 BiFunction<U, ? super T, U> accumulator,
                 BinaryOperator<U> combiner);
    #+end_src

    #+REVEAL: split

    #+begin_src java
    Map<Long, User> userMap = Maps.newHashMap();
    for (User user : users) {
        userMap.put(user.getId(), user);
    }
    #+end_src

    #+ATTR_REVEAL: :frag fade-in-then-out
    #+begin_src java
    users.stream().reduce(
                          Collections.emptyMap(),
                          (Map<Long, User> acc, User user) -> {
                              acc.put(user.getId(), user);
                              return acc;
                          }, (acc1, acc2) -> {
                              acc1.putAll(acc2);
                              return acc1;
                          });
    #+end_src

    #+ATTR_REVEAL: :frag fade-in-then-out
    #+begin_src java
    users.stream().reduce(
                          Collections.emptyMap(),
                          (Map<Long, User> acc, User user) -> {
                              HashMap<Long, User> newAcc = Maps.newHashMap(acc);
                              newAcc.put(user.getId(), user);
                              return newAcc;
                          }, (acc1, acc2) -> {
                              HashMap<Long, User> newAcc = Maps.newHashMap(acc1);
                              newAcc.putAll(acc2);
                              return newAcc;
                          });
    #+end_src

    #+ATTR_REVEAL: :frag t
    #+begin_src java
    users.stream().collect(Collectors.toMap(User::getId, Function.identity()));
    #+end_src

    #+REVEAL: split

    #+begin_src java
    List<String> friends = ...;

    Optional<String> longestName = Optional.empty();
    for (String name : friends) {
        if (!longestName.isPresent()) {
            longestName = Optional.of(name);
            continue;
        }
        if (name.length() >= longestName.get().length()) {
            longestName = Optional.of(name);
        }
    }
    #+end_src

    #+ATTR_REVEAL: :frag t
    #+begin_src java
    List<String> friends = ...;

    Optional<String> longestName = friends.stream()
        .reduce((name1, name2) ->
                name1.length() >= name2.length() ? name1 : name2);
    #+end_src

** optional

   Java SE 8 introduces a new class called =java.util.Optional<T>= that is inspired from the ideas of Haskell (=Maybe t=) and Scala (=Option[T]=). It is a class that encapsulates an optional value. You can view =Optional= as a single-value container that either contains a value or doesn't (it is then said to be "empty").

   [[./imgs/optional.gif]]

   #+REVEAL: split

   #+begin_quote
   you are not a real Java programmer until you've dealt with a null pointer exception
   #+end_quote

   
*** 一个例子
    
    假设我们要追溯克隆羊的实验，我们想知道羊的基因历史，我们提供了 =father=, =mother= 方法用来查找羊的双亲，但是由于这些羊中有一些是克隆羊，所以这些羊不一定都有父母。

    #+begin_src java
    class Sheep {}

    public static Sheep father(Sheep sheep) {
        // ...
    }

    public static Sheep mother(Sheep sheep) {
        // ...
    }
    #+end_src

*** 定义函数 =maternalGrandfather= ，找羊的外祖父
    #+begin_src java
    public static Sheep maternalGrandfather(Sheep s) {
        Sheep m = mother(s);
        if (m != null) {
            return father(m);
        }
        return null;
    }
    #+end_src

*** 定义函数 =mothersPaternalGrandfather= 找羊的曾外祖父(妈的爸的爸)
    #+begin_src java
    public static Sheep mothersPaternalGrandfather(Sheep s) {
        Sheep m = mother(s);
        if (m != null) {
            Sheep f = father(m);
            if (f != null) {
                return father(f);
            }
        }
        return null;
    }
    #+end_src

*** 定义函数曾曾曾..........外祖父？

    #+ATTR_REVEAL: :frag t
    #+ATTR_ORG: :width 400
    [[./imgs/if-hell.jpeg]]

*** 如果我们使用 =Optional=
    
    #+begin_src java
    public static Optional<Sheep> fatherOpt(Sheep sheep) {
        return Optional.ofNullable(father(sheep));
    }

    public static Optional<Sheep> motherOpt(Sheep sheep) {
        return Optional.ofNullable(mother(sheep));
    }
    #+end_src

*** 定义函数 =maternalGrandfatherOpt= ，找羊的外祖父

    #+begin_src java
    public static Optional<Sheep> maternalGrandfatherOpt(Sheep s) {
        return motherOpt(s).flatMap(OptionalSample::fatherOpt);
    }
    #+end_src

*** 现在定义函数 =mothersPaternalGrandfatherOpt= 找羊的曾外祖父(妈的爸的爸)
    
    #+begin_src java
    public static Optional<Sheep> mothersPaternalGrandfatherOpt(Sheep s) {
        return motherOpt(s)
            .flatMap(OptionalSample::fatherOpt)
            .flatMap(OptionalSample::fatherOpt);
    }
    #+end_src

    
*** 现在定义函数 =mothersFathersMothersFathersMotherOpt= 找羊的妈的爸的妈的爸的妈

    #+begin_src java
    public static Optional<Sheep> mothersFathersMothersFathersMotherOpt(Sheep s) {
        return motherOpt(s)
            .flatMap(OptionalSample::fatherOpt)
            .flatMap(OptionalSample::motherOpt)
            .flatMap(OptionalSample::fatherOpt)
            .flatMap(OptionalSample::motherOpt);
    }
    #+end_src

** working with resources

   #+ATTR_REVEAL: :frag t
   #+begin_src java
   interface RedisOperation<T> {
       T run(Jedis jedis);
   }
   #+end_src

   #+ATTR_REVEAL: :frag t
   #+begin_src java
   class JedisPoolWrapper {
       private final JedisPool pool;
       public JedisPoolWrapper(JedisPool pool) {
           this.pool = pool;
       }
       public <T> T run(RedisOperation<T> operation) {
           Jedis resource = pool.getResource();
           try {
               return operation.run(resource);
           } finally {
               pool.returnResource(resource);
           }
       }
   }
   #+end_src

   #+ATTR_REVEAL: :frag t
   #+begin_src java
   jedisPoolWrapper.run(jedis -> jedis.get("hello.world"));
   #+end_src

** optimizing recursions

   
*** Tail-Call Optimization (TCO)

    #+begin_src c
    #include <stdio.h>

    int even(int n);
    int odd(int n);

    int even(int n) {
      if (n == 0) {
        return 1;
      }
      return odd(n - 1);
    }

    int odd(int n) {
      if (n == 0) {
        return 0;
      }
      return even(n - 1);
    }

    int main() {
      printf("%d", even(1000000));
    }
    #+end_src

    #+REVEAL: split

    #+ATTR_REVEAL: :frag t
    #+begin_src text
    $ gcc main.c && ./a.out
    #+end_src
    
    #+ATTR_REVEAL: :frag t
    #+begin_src text
    [1]    79338 segmentation fault  ./a.out
    #+end_src

    #+ATTR_REVEAL: :frag t
    #+begin_src text
    $ gcc -O2 main.c && ./a.out
    #+end_src
    
    #+ATTR_REVEAL: :frag t
    #+begin_src text
    1
    #+end_src

    #+REVEAL: split

    #+begin_src text
    $ gcc -S -O2 main.c -o main_tco.s
    $ gcc -S main.c -o main_no_tco.s
    #+end_src

    #+ATTR_REVEAL: :frag fade-in-then-out
    #+ATTR_ORG: :width 800
    [[./imgs/Xnip2020-06-03_13-55-16.png]]

    #+ATTR_REVEAL: :frag t
    #+begin_src c
    int even(int n) {
      if (n == 0) {
        return 1;
      }
     LBB0_2:
      if (n == 1) {
        return 0;
      }
      n-=2;
      if (n != 0) {
        goto LBB0_2;
      }
      return 1;
    }
    #+end_src

*** Java does not provide Tail-Call Optimization (TCO)

    #+begin_src java
    package org.xusheng.ioliw.tco;

    public class NoTCO {
        private static boolean even(int n) {
            if (n == 0) {
                return true;
            }
            return odd(n - 1);
        }

        private static boolean odd(int n) {
            if (n == 0) {
                return false;
            }
            return even(n - 1);
        }

        public static void main(String[] args) {
            System.out.println(even(100000));
        }
    }
    #+end_src

    #+REVEAL: split

    #+begin_src text
    Exception in thread "main" java.lang.StackOverflowError
      at org.xusheng.ioliw.tco.NoTCO.odd(NoTCO.java:15)
      at org.xusheng.ioliw.tco.NoTCO.even(NoTCO.java:8)
      at org.xusheng.ioliw.tco.NoTCO.odd(NoTCO.java:15)
      at org.xusheng.ioliw.tco.NoTCO.even(NoTCO.java:8)
      at org.xusheng.ioliw.tco.NoTCO.odd(NoTCO.java:15)
    ...
    #+end_src

    
*** Trampolines

    [[./imgs/trampoline.png]]

    #+REVEAL: split

    #+begin_src java
    package org.xusheng.ioliw.tco;

    import java.util.stream.Stream;

    public interface Trampoline<T> {
        T get();

        default Trampoline<T> jump() {
            return this;
        }

        default T result() {
            return get();
        }

        default boolean complete() {
            return true;
        }
    }
    #+end_src

    #+REVEAL: split

    #+begin_src java
    static <T> Trampoline<T> done(final T result) {
        return () -> result;
    }
    #+end_src

    #+REVEAL: split

    #+begin_src java
    static <T> Trampoline<T> more(final Trampoline<Trampoline<T>> trampoline) {
        return new Trampoline<T>() {
            @Override
            public boolean complete() {
                return false;
            }

            @Override
            public Trampoline<T> jump() {
                return trampoline.result();
            }

            @Override
            public T get() {
                return trampoline(this);
            }

            T trampoline(final Trampoline<T> trampoline) {
                return Stream.iterate(trampoline, Trampoline::jump)
                    .filter(Trampoline::complete)
                    .findFirst()
                    .map(Trampoline::result)
                    .orElse(null);
            }
        };
    }
    #+end_src

    #+REVEAL: split
    
    #+begin_src java
    package org.xusheng.ioliw.tco;

    import static org.xusheng.ioliw.tco.Trampoline.done;
    import static org.xusheng.ioliw.tco.Trampoline.more;

    public class UseTrampoline {
        public static Trampoline<Boolean> evenRec(int n) {
            if (n == 0) {
                return done(true);
            }
            return more(() -> oddRec(n - 1));
        }

        public static Trampoline<Boolean> oddRec(int n) {
            if (n == 0) {
                return done(false);
            }
            return more(() -> evenRec(n - 1));
        }

        public static void main(String[] args) {
            System.out.println(evenRec(100000).get());
        }
    }
    #+end_src

    #+REVEAL: split

    #+begin_src java
    public static long fibonacciNaive(long n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        return fibonacciNaive(n - 1) + fibonacciNaive(n - 2);
    }

    public static Trampoline<Long> fibonacci(long step, long a, long b) {
        if (step == 0) {
            return done(a);
        }
        return more(() -> fibonacci(step - 1, b, a + b));
    }

    public static void main(String[] args) {
        System.out.println(fibonacci(45, 0, 1).get());
        System.out.println(fibonacciNaive(45));
    }
    #+end_src

    #+REVEAL: split
    
    #+ATTR_ORG: :width 400
    [[./imgs/trampoline-class.png]]
     
* Haskell函数式编程语言

  #+ATTR_HTML: :style background-color: white;
  [[./imgs/haskell-logo.svg]]

  #+begin_quote
  An advanced, purely functional programming language
  #+end_quote

** 关于 ~Haskell~ 的段子
   
*** how to learn Haskell

    #+ATTR_ORG: :width 400
    [[./imgs/howtolearnhaskell.png]]

*** learning curves for different programming languages

    #+ATTR_REVEAL: :frag fade-in-then-out
    #+ATTR_ORG: :width 400
    [[./imgs/java.png]]

    #+ATTR_REVEAL: :frag t
    #+ATTR_ORG: :width 400
    [[./imgs/haskell.png]]

    #+REVEAL: split

    #+ATTR_ORG: :width 400
    #+ATTR_HTML: :style width: 70%;
    [[./imgs/learningcurve.jpg]]

*** code written in Haskell is guaranteed to have no side effects

    #+ATTR_ORG: :width 400
    #+ATTR_HTML: :style width: 30%;
    [[./imgs/haskell_2x.png]]

*** 我大概看了这本书十年
    ~Real World Hashell~
    #+ATTR_ORG: :width 400
    [[./imgs/realworldhaskell.jpg]]

** pure function
   
   在程序设计中，若一个函数符合以下要求，则它可能被认为是纯函数：

   1. 此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关。
   2. 该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。

   #+REVEAL: split

   #+begin_src haskell
   double :: Int -> Int
   double i = i + i

   square :: Int -> Int
   square i = i * i

   factorial :: Integer -> Integer
   factorial n = product [1..n]
   #+end_src

** immutable data

   #+begin_src haskell
   data Person = Person { firstName :: String
                        , lastName :: String
                        } deriving (Show)

   p1 = Person { firstName = "Shane", lastName = "Xu" }

   p2 = p1 { firstName = "Sheng" }

   data User = User Int String
   #+end_src

** first-class function

   #+begin_src haskell
   add :: Int -> Int -> Int
   add a b = a + b

   adder1 :: Int -> Int
   adder1 x = x + 1

   adder1' = add 1

   multiply :: Int -> Int -> Int
   multiply a b = a * b

   multiplier2 = multiply 2

   add1ThenMultiply2 = multiplier2 . adder1

   map plus1ThenMultiply2 [1, 2, 3]

   map (\i -> ( i + 1) * 2) [1, 2, 3]
   #+end_src

** lazy
   
   #+begin_src haskell
   fib = 0 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]

   take 11 fib

   fib !! 11
   #+end_src

** handle side effect

   #+begin_src haskell
   hello :: String -> IO ()
   hello who = putStrLn ("Hello, " ++ who ++ "!")

   main :: IO ()
   main = hello "World"
   #+end_src

** Functor(函子), Applicative Functor(应用函子), Monad(单子)
   
*** Functor

    #+begin_src haskell
    class Functor f where
        fmap :: (a -> b) -> f a -> f b
    #+end_src

*** Applicative

    #+begin_src haskell
    class (Functor f) => Applicative f where
        pure  :: a -> f a
        (<*>) :: f (a -> b) -> f a -> f b'
    #+end_src

*** Monad

    #+begin_src haskell
    class Monad m where
        (>>=)  :: m a -> (a -> m b) -> m b
        (>>)   :: m a ->  m b       -> m b
        return ::   a               -> m a
        fail   :: String -> m a
    #+end_src
