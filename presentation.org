#+TITLE:       如果我们的语言是威士忌——函数式编程初窥
#+AUTHOR:      Xu Sheng
#+EMAIL:       sheng.xu@sumscope.com
#+DATE:        2020-09-12
#+OPTIONS:     toc:1 reveal_single_file:nil reveal_history:t reveal_width:1200 reveal_height:800

#+REVEAL_ROOT:              ./reveal.js-4.0.2
#+REVEAL_REVEAL_JS_VERSION: 4
#+REVEAL_THEME:             black
#+REVEAL_PLUGINS:           (highlight)
#+REVEAL_EXTRA_CSS:         ./presentation.css


* 前言

  * Java8引入的“新”特性
  * Haskell
  * 函数复合、高阶函数、懒惰求值、不可变数据
  * 纯函数、副作用、函子、应用函子、单子

** 费曼的彩虹

   #+begin_quote
   “那你觉得彩虹的哪一个特色，让笛卡儿产生做数学分析的灵感？” \\
   “其实彩虹是圆锥体的一段，当水滴被来自观察者后方的光线照射时，会呈现出弧状的光谱颜色。我想他的灵感来自于他发现可以藉由思考单一的水滴，以及它的几何位置来分析这个问题。”\\
   #+end_quote

   #+REVEAL: split

   #+begin_quote
   “我会说他的灵感来自于他认为彩虹很美。”\\

   《费曼的彩虹:物理大师的最后24堂课》
   #+end_quote

   
** Lambda
   
   #+ATTR_ORG: :width 800
   #+ATTR_HTML: :style width: 70%;
   [[./imgs/lambda_rainbow.png]]

* Java函数式编程

  #+begin_quote
  March 18, 2014
  #+end_quote

  #+REVEAL: split

  #+begin_quote
  Java Programming Language

  1. Lambda Expressions, a new language feature, has been introduced in this release. 
  2. Method references provide easy-to-read lambda expressions for methods that already have a name.
  #+end_quote

  #+REVEAL: split

  #+begin_quote
  Collections
  
  1. Classes in the new java.util.stream package provide a Stream API to support functional-style operations on streams of elements. 
  #+end_quote

** stream

*** Iterating through a List

    #+begin_src java
    for(T t : listOfT) {
        // do something
    }
    #+end_src

    #+ATTR_REVEAL: :frag t
    #+begin_src java
    void forEach(Consumer<? super T> action);
    #+end_src

    #+REVEAL: split

    #+begin_src java
    final List<String> friends =
        Arrays.asList("Brian", "Nate", "Neal", "Raju", "Sara", "Scott");

    for(String name : friends) {
        System.out.println(name);
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    friends.forEach((final String name) -> System.out.println(name));
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    friends.forEach((name) -> System.out.println(name));
    #+end_src

    #+ATTR_REVEAL: :frag frag-style    
    #+begin_src java
    friends.forEach(name -> System.out.println(name));
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    friends.forEach(System.out::println);
    #+end_src

*** Transforming a List
    
    #+begin_src java
    List<R> listOfR = new ArrayList<>();
    for(T t : listOfT) {
        R r = map(t);
        listOfR.put(r);
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    <R> Stream<R> map(Function<? super T, ? extends R> mapper);
    #+end_src

    #+REVEAL: split

    #+begin_src java
    final List<String> uppercaseNames = new ArrayList<String>();
    for(String name : friends) {
        uppercaseNames.add(name.toUpperCase());
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    final List<String> uppercaseNames = new ArrayList<String>();
    friends.forEach(name -> uppercaseNames.add(name.toUpperCase()));
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    friends.stream().map(name -> name.toUpperCase());
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    friends.stream().map(String::toUpperCase);
    #+end_src

*** Finding Elements

    #+begin_src java
    List filteredListOfT = new LinkedList<>();
    for(T t : listOfT) {
        if (predicate(t)) {
            filteredListOfT.add(t);
        }
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    Stream<T> filter(Predicate<? super T> predicate);
    #+end_src

    #+REVEAL: split

    #+begin_src java
    final List<String> startsWithN = new ArrayList<String>();
    for(String name : friends) {
        if(name.startsWith("N")) {
            startsWithN.add(name);
        }
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    final List<String> startsWithN = friends.stream()
        .filter(name -> name.startsWith("N")).collect(Collectors.toList());
    #+end_src

*** Reducing a Collection to a Single Value

    #+begin_src java
    T result = null;
    for (int i = 0; i < listOfT.size(); i++) {
        T t = listOfT.get(i);
        if (i == 0) {
            result = t;
            continue;
        }
        result = accumulator(t, result);
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    Optional<T> reduce(BinaryOperator<T> accumulator);
    #+end_src

    #+REVEAL: split

    #+begin_src java
    T result = identity;
    for (T t : listOfT) {
        result = accumulator(t, result);
    }
    #+end_src

    #+ATTR_REVEAL: :frag frag-style
    #+begin_src java
    T reduce(T identity, BinaryOperator<T> accumulator);
    #+end_src
    
    #+REVEAL: split

    #+begin_src java
    U result = identity;
    for (T t : listOfT) {
        U partialResult = accumulator(t, result);
        result = combiner(result, partialResult);
    }
    #+end_src
    
    #+ATTR_REVEAL: :frag t
    #+begin_src java
    <U> U reduce(U identity,
                 BiFunction<U, ? super T, U> accumulator,
                 BinaryOperator<U> combiner);
    #+end_src

    #+REVEAL: split

    #+begin_src java
    Map<Long, User> userMap = Maps.newHashMap();
    for (User user : users) {
        userMap.put(user.getId(), user);
    }
    #+end_src

    #+ATTR_REVEAL: :frag fade-in-then-out
    #+begin_src java
    users.stream().reduce(
                          Collections.emptyMap(),
                          (Map<Long, User> acc, User user) -> {
                              acc.put(user.getId(), user);
                              return acc;
                          }, (acc1, acc2) -> {
                              acc1.putAll(acc2);
                              return acc1;
                          });
    #+end_src

    #+ATTR_REVEAL: :frag fade-in-then-out
    #+begin_src java
    users.stream().reduce(
                          Collections.emptyMap(),
                          (Map<Long, User> acc, User user) -> {
                              HashMap<Long, User> newAcc = Maps.newHashMap(acc);
                              newAcc.put(user.getId(), user);
                              return newAcc;
                          }, (acc1, acc2) -> {
                              HashMap<Long, User> newAcc = Maps.newHashMap(acc1);
                              newAcc.putAll(acc2);
                              return newAcc;
                          });
    #+end_src

    #+ATTR_REVEAL: :frag t
    #+begin_src java
    users.stream().collect(Collectors.toMap(User::getId, Function.identity()));
    #+end_src

    #+REVEAL: split

    #+begin_src java
    List<String> friends = ...;

    Optional<String> longestName = Optional.empty();
    for (String name : friends) {
        if (!longestName.isPresent()) {
            longestName = Optional.of(name);
            continue;
        }
        if (name.length() >= longestName.get().length()) {
            longestName = Optional.of(name);
        }
    }
    #+end_src

    #+ATTR_REVEAL: :frag t
    #+begin_src java
    List<String> friends = ...;

    Optional<String> longestName = friends.stream()
        .reduce((name1, name2) ->
                name1.length() >= name2.length() ? name1 : name2);
    #+end_src

** optional

   Java SE 8 introduces a new class called =java.util.Optional<T>= that is inspired from the ideas of Haskell (=Maybe t=) and Scala (=Option[T]=). It is a class that encapsulates an optional value. You can view =Optional= as a single-value container that either contains a value or doesn't (it is then said to be "empty").

   [[./imgs/optional.gif]]

   #+REVEAL: split

   #+begin_quote
   you are not a real Java programmer until you've dealt with a null pointer exception
   #+end_quote

   
*** 一个例子
    
    假设我们要追溯克隆羊的实验，我们想知道羊的基因历史，我们提供了 =father=, =mother= 方法用来查找羊的双亲，但是由于这些羊中有一些是克隆羊，所以这些羊不一定都有父母。

    #+begin_src java
    class Sheep {}

    public static Sheep father(Sheep sheep) {
        // ...
    }

    public static Sheep mother(Sheep sheep) {
        // ...
    }
    #+end_src

*** 定义函数 =maternalGrandfather= ，找羊的外祖父
    #+begin_src java
    public static Sheep maternalGrandfather(Sheep s) {
        Sheep m = mother(s);
        if (m != null) {
            return father(m);
        }
        return null;
    }
    #+end_src

*** 定义函数 =mothersPaternalGrandfather= 找羊的曾外祖父(妈的爸的爸)
    #+begin_src java
    public static Sheep mothersPaternalGrandfather(Sheep s) {
        Sheep m = mother(s);
        if (m != null) {
            Sheep f = father(m);
            if (f != null) {
                return father(f);
            }
        }
        return null;
    }
    #+end_src

*** 定义函数曾曾曾..........外祖父？

    #+ATTR_REVEAL: :frag t
    #+ATTR_ORG: :width 400
    [[./imgs/if-hell.jpeg]]

*** 如果我们使用 =Optional=
    
    #+begin_src java
    public static Optional<Sheep> fatherOpt(Sheep sheep) {
        return Optional.ofNullable(father(sheep));
    }

    public static Optional<Sheep> motherOpt(Sheep sheep) {
        return Optional.ofNullable(mother(sheep));
    }
    #+end_src

*** 定义函数 =maternalGrandfatherOpt= ，找羊的外祖父

    #+begin_src java
    public static Optional<Sheep> maternalGrandfatherOpt(Sheep s) {
        return motherOpt(s).flatMap(OptionalSample::fatherOpt);
    }
    #+end_src

*** 现在定义函数 =mothersPaternalGrandfatherOpt= 找羊的曾外祖父(妈的爸的爸)
    
    #+begin_src java
    public static Optional<Sheep> mothersPaternalGrandfatherOpt(Sheep s) {
        return motherOpt(s)
            .flatMap(OptionalSample::fatherOpt)
            .flatMap(OptionalSample::fatherOpt);
    }
    #+end_src

    
*** 现在定义函数 =mothersFathersMothersFathersMotherOpt= 找羊的妈的爸的妈的爸的妈

    #+begin_src java
    public static Optional<Sheep> mothersFathersMothersFathersMotherOpt(Sheep s) {
        return motherOpt(s)
            .flatMap(OptionalSample::fatherOpt)
            .flatMap(OptionalSample::motherOpt)
            .flatMap(OptionalSample::fatherOpt)
            .flatMap(OptionalSample::motherOpt);
    }
    #+end_src

** working with resources

   #+ATTR_REVEAL: :frag t
   #+begin_src java
   interface RedisOperation<T> {
       T run(Jedis jedis);
   }
   #+end_src

   #+ATTR_REVEAL: :frag t
   #+begin_src java
   class JedisPoolWrapper {
       private final JedisPool pool;
       public JedisPoolWrapper(JedisPool pool) {
           this.pool = pool;
       }
       public <T> T run(RedisOperation<T> operation) {
           Jedis resource = pool.getResource();
           try {
               return operation.run(resource);
           } finally {
               pool.returnResource(resource);
           }
       }
   }
   #+end_src

   #+ATTR_REVEAL: :frag t
   #+begin_src java
   jedisPoolWrapper.run(jedis -> jedis.get("hello.world"));
   #+end_src

** optimizing recursions

   
*** Tail-Call Optimization (TCO)

    #+begin_src c
    #include <stdio.h>

    int even(int n);
    int odd(int n);

    int even(int n) {
      if (n == 0) {
        return 1;
      }
      return odd(n - 1);
    }

    int odd(int n) {
      if (n == 0) {
        return 0;
      }
      return even(n - 1);
    }

    int main() {
      printf("%d", even(1000000));
    }
    #+end_src

    #+REVEAL: split

    #+ATTR_REVEAL: :frag t
    #+begin_src text
    $ gcc main.c && ./a.out
    #+end_src
    
    #+ATTR_REVEAL: :frag t
    #+begin_src text
    [1]    79338 segmentation fault  ./a.out
    #+end_src

    #+ATTR_REVEAL: :frag t
    #+begin_src text
    $ gcc -O2 main.c && ./a.out
    #+end_src
    
    #+ATTR_REVEAL: :frag t
    #+begin_src text
    1
    #+end_src

    #+REVEAL: split

    #+begin_src text
    $ gcc -S -O2 main.c -o main_tco.s
    $ gcc -S main.c -o main_no_tco.s
    #+end_src

    #+ATTR_REVEAL: :frag fade-in-then-out
    #+ATTR_ORG: :width 800
    [[./imgs/Xnip2020-06-03_13-55-16.png]]

    #+ATTR_REVEAL: :frag t
    #+begin_src c
    int even(int n) {
      if (n == 0) {
        return 1;
      }
     LBB0_2:
      if (n == 1) {
        return 0;
      }
      n-=2;
      if (n != 0) {
        goto LBB0_2;
      }
      return 1;
    }
    #+end_src

*** Java does not provide Tail-Call Optimization (TCO)

    #+begin_src java
    package org.xusheng.ioliw.tco;

    public class NoTCO {
        private static boolean even(int n) {
            if (n == 0) {
                return true;
            }
            return odd(n - 1);
        }

        private static boolean odd(int n) {
            if (n == 0) {
                return false;
            }
            return even(n - 1);
        }

        public static void main(String[] args) {
            System.out.println(even(100000));
        }
    }
    #+end_src

    #+REVEAL: split

    #+begin_src text
    Exception in thread "main" java.lang.StackOverflowError
      at org.xusheng.ioliw.tco.NoTCO.odd(NoTCO.java:15)
      at org.xusheng.ioliw.tco.NoTCO.even(NoTCO.java:8)
      at org.xusheng.ioliw.tco.NoTCO.odd(NoTCO.java:15)
      at org.xusheng.ioliw.tco.NoTCO.even(NoTCO.java:8)
      at org.xusheng.ioliw.tco.NoTCO.odd(NoTCO.java:15)
    ...
    #+end_src

    
*** Trampolines

    [[./imgs/trampoline.png]]

    #+REVEAL: split

    #+begin_src java
    package org.xusheng.ioliw.tco;

    import java.util.stream.Stream;

    public interface Trampoline<T> {
        T get();

        default Trampoline<T> jump() {
            return this;
        }

        default T result() {
            return get();
        }

        default boolean complete() {
            return true;
        }
    }
    #+end_src

    #+REVEAL: split

    #+begin_src java
    static <T> Trampoline<T> done(final T result) {
        return () -> result;
    }
    #+end_src

    #+REVEAL: split

    #+begin_src java
    static <T> Trampoline<T> more(final Trampoline<Trampoline<T>> trampoline) {
        return new Trampoline<T>() {
            @Override
            public boolean complete() {
                return false;
            }

            @Override
            public Trampoline<T> jump() {
                return trampoline.result();
            }

            @Override
            public T get() {
                return trampoline(this);
            }

            T trampoline(final Trampoline<T> trampoline) {
                return Stream.iterate(trampoline, Trampoline::jump)
                    .filter(Trampoline::complete)
                    .findFirst()
                    .map(Trampoline::result)
                    .orElse(null);
            }
        };
    }
    #+end_src

    #+REVEAL: split
    
    #+begin_src java
    package org.xusheng.ioliw.tco;

    import static org.xusheng.ioliw.tco.Trampoline.done;
    import static org.xusheng.ioliw.tco.Trampoline.more;

    public class UseTrampoline {
        public static Trampoline<Boolean> evenRec(int n) {
            if (n == 0) {
                return done(true);
            }
            return more(() -> oddRec(n - 1));
        }

        public static Trampoline<Boolean> oddRec(int n) {
            if (n == 0) {
                return done(false);
            }
            return more(() -> evenRec(n - 1));
        }

        public static void main(String[] args) {
            System.out.println(evenRec(100000).get());
        }
    }
    #+end_src

    #+REVEAL: split

    #+begin_src java
    public static long fibonacciNaive(long n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        return fibonacciNaive(n - 1) + fibonacciNaive(n - 2);
    }

    public static Trampoline<Long> fibonacci(long step, long a, long b) {
        if (step == 0) {
            return done(a);
        }
        return more(() -> fibonacci(step - 1, b, a + b));
    }

    public static void main(String[] args) {
        System.out.println(fibonacci(45, 0, 1).get());
        System.out.println(fibonacciNaive(45));
    }
    #+end_src

    #+REVEAL: split
    
    #+ATTR_ORG: :width 400
    [[./imgs/trampoline-class.png]]
     
* Haskell函数式编程语言

  #+ATTR_HTML: :style background-color: white;
  [[./imgs/haskell-logo.svg]]

  #+begin_quote
  An advanced, purely functional programming language
  #+end_quote

** 关于 ~Haskell~ 的段子
   
*** how to learn Haskell

    #+ATTR_ORG: :width 400
    [[./imgs/howtolearnhaskell.png]]

*** learning curves for different programming languages

    #+ATTR_REVEAL: :frag fade-in-then-out
    #+ATTR_ORG: :width 400
    [[./imgs/java.png]]

    #+ATTR_REVEAL: :frag t
    #+ATTR_ORG: :width 400
    [[./imgs/haskell.png]]

    #+REVEAL: split

    #+ATTR_ORG: :width 400
    #+ATTR_HTML: :style width: 70%;
    [[./imgs/learningcurve.jpg]]

*** code written in Haskell is guaranteed to have no side effects

    #+ATTR_ORG: :width 400
    #+ATTR_HTML: :style width: 30%;
    [[./imgs/haskell_2x.png]]

*** 我大概看了这本书十年
    ~Real World Hashell~
    #+ATTR_ORG: :width 400
    [[./imgs/realworldhaskell.jpg]]

** pure function
   
   在程序设计中，若一个函数符合以下要求，则它可能被认为是纯函数：

   1. 此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关。
   2. 该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。

   #+REVEAL: split

   #+begin_src haskell
   double :: Int -> Int
   double i = i + i

   square :: Int -> Int
   square i = i * i

   factorial :: Integer -> Integer
   factorial n = product [1..n]
   #+end_src

** immutable data

   #+begin_src haskell
   data Person = Person { firstName :: String
                        , lastName :: String
                        } deriving (Show)

   p1 = Person { firstName = "Shane", lastName = "Xu" }

   p2 = p1 { firstName = "Sheng" }

   data User = User Int String
   #+end_src

** first-class function

   #+begin_src haskell
   add :: Int -> Int -> Int
   add a b = a + b

   adder1 :: Int -> Int
   adder1 x = x + 1

   adder1' = add 1

   multiply :: Int -> Int -> Int
   multiply a b = a * b

   multiplier2 = multiply 2

   add1ThenMultiply2 = multiplier2 . adder1

   map plus1ThenMultiply2 [1, 2, 3]

   map (\i -> ( i + 1) * 2) [1, 2, 3]
   #+end_src

** lazy
   
   #+begin_src haskell
   fib = 0 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]

   take 11 fib

   fib !! 11
   #+end_src

** handle side effect

   #+begin_src haskell
   hello :: String -> IO ()
   hello who = putStrLn ("Hello, " ++ who ++ "!")

   main :: IO ()
   main = hello "World"
   #+end_src

** Functor(函子), Applicative Functor(应用函子), Monad(单子)
   
*** Functor

    #+begin_src haskell
    class Functor f where
        fmap :: (a -> b) -> f a -> f b
    #+end_src

*** Applicative

    #+begin_src haskell
    class (Functor f) => Applicative f where
        pure  :: a -> f a
        (<*>) :: f (a -> b) -> f a -> f b'
    #+end_src

*** Monad

    #+begin_src haskell
    class Monad m where
        (>>=)  :: m a -> (a -> m b) -> m b
        (>>)   :: m a ->  m b       -> m b
        return ::   a               -> m a
        fail   :: String -> m a
    #+end_src

    #+REVEAL: split

    Optional
    #+begin_src haskell
    data Optional t
      = Some t
      | None deriving (Eq, Ord, Show)
    #+end_src
       
    #+begin_src haskell
    instance Functor Optional where
      fmap _ None = None
      fmap f (Some x)  = Some (f x)
    #+end_src

    #+begin_src haskell
    instance Applicative Optional where
      pure = Some
      None <*> a = None
      Some f <*> a = fmap f a
    #+end_src

    #+begin_src haskell
    instance Monad Optional where
      None >>= f = None
      Some x >>= f = f x
    #+end_src
         
    #+REVEAL: split

    Maybe is a Monad

    #+begin_src haskell
    Just 1
      >> return 2
      >>= \t -> return (t+1)
    #+end_src

    #+REVEAL: split

    ~>>=~ (bind function)

    Haskell的 ~Maybe~ 就是Java的 ~Optional~ 。
    ~>>=~ 操作符或者叫 ~bind~ 函数，其实就是 ~flatMap~ 。

    #+REVEAL: split

    让我们解决羊的问题，

    #+begin_src haskell
    data Sheep = Sheep Int Name

    fatherMaybe :: Sheep -> Maybe Sheep
    fatherMaybe s = undefined

    motherMaybe :: Sheep -> Maybe Sheep
    motherMaybe = undefined
    #+end_src

    #+REVEAL: split

    定义函数 =mothersFathersMothersFathersMotherMaybe= 找羊的妈的爸的妈的爸的妈
    #+begin_src haskell
    mothersFathersMothersFathersMotherMaybe :: Sheep -> Maybe Sheep
    mothersFathersMothersFathersMotherMaybe s =
      motherMaybe s >>=
      fatherMaybe >>=
      motherMaybe >>=
      fatherMaybe >>=
      motherMaybe
    #+end_src

    #+REVEAL: split

    IO is a Monad

    #+begin_src haskell
    putStrLn "Who are you?"
      >> getLine
      >>= \name -> putStrLn ("Hello, " ++ name ++ "!")
    #+end_src

    #+begin_src text
    Prelude> :{
    Prelude| :type putStrLn "Who are you?"
    Prelude|   >> getLine
    Prelude|   >>= \name -> putStrLn ("Hello, " ++ name ++ "!")
    Prelude| :}
    putStrLn "Who are you?"
      >> getLine
      >>= \name -> putStrLn ("Hello, " ++ name ++ "!")
      :: IO ()
    Prelude>
    #+end_src

    #+begin_src haskell
    do
      name <- getLine
      putStrLn ("Hello, " ++ name + "!")
    #+end_src

    #+REVEAL: split

    Why Monad?

    1. Modularity
    2. Flexibility
    3. Isolation
       
* Haxl

  [[./imgs/haxl-logo.png]]

  Haxl是一个基于Monad的优雅的数据加载框架。

  #+ATTR_REVEAL: :frag (appear)
  1. batch multiple requests to the same data source,
  2. request data from multiple data sources concurrently,
  3. cache previous requests,
  4. memoize computations.

** fun with haxl
   
   [[https://github.com/shanexu/FunWithHaxl]]

   #+begin_src text
   $ stack setup
   $ stack run
   #+end_src

   #+REVEAL: split

   #+begin_src haskell
   {-# LANGUAGE OverloadedStrings #-}

   module Main where

   import System.Environment
   import qualified HaxlBlog as H
   import qualified BlogDB as R

   defaultDB = "blog.sqlite"

   main :: IO ()
   main = do
     putStrLn "raw:"
     R.run (R.getPostIds >>= mapM R.getPostContent) >>= print
     putStrLn "haxl:"
     H.run (H.getPostIds >>= mapM H.getPostContent) >>= print
   #+end_src

   #+REVEAL: split
   
   #+begin_src text
   raw:
   select postid from postinfo;
   select content from postcontent where postid = 1;
   select content from postcontent where postid = 2;
   select content from postcontent where postid = 3;
   select content from postcontent where postid = 4;
   select content from postcontent where postid = 5;
   select content from postcontent where postid = 6;
   select content from postcontent where postid = 7;
   select content from postcontent where postid = 8;
   select content from postcontent where postid = 9;
   select content from postcontent where postid = 10;
   select content from postcontent where postid = 11;
   select content from postcontent where postid = 12;
   ["example content 1","example content 2","example content 3","example content 4","example content 5","example content 6","example content 7","example content 8","example content 9","example content 10","example content 11","example content 12"]
   haxl:
   select postid from postinfo;
   select postid,content from postcontent where postid in (12,11,10,9,8,7,6,5,4,3,2,1);
   ["example content 1","example content 2","example content 3","example content 4","example content 5","example content 6","example content 7","example content 8","example content 9","example content 10","example content 11","example content 12"]
   #+end_src

** make a plain

   假设几个数据之间依赖关系如下：
   #+begin_src dot :exports results :file ./imgs/deps.png :cmdline -Kdot -Tpng :hidden
   digraph G {
     "A" -> "B"
     "A" -> "C"
     "B" -> "D"
     "B" -> "E"
     "C" -> "F"
     "C" -> "E"
   }
   #+end_src

   #+RESULTS:
   [[file:./imgs/deps.png]]
   
   #+REVEAL: split

   一种资源获取/计算的执行计划可以如下：
   #+begin_src dot :exports results :file ./imgs/schedule.png :cmdline -Kdot -Tpng :hidden
   digraph G {
     rankdir="LR";
     node [shape=box];
     "D, E, F" -> "B, C" -> "A"
   }
   #+end_src

   #+RESULTS:
   [[file:./imgs/schedule.png]]

** scala fetch

   #+ATTR_HTML: :style background-color: white;
   [[./imgs/fetch-logo.svg]]

   [[https://github.com/47degrees/fetch]]

*** 一个例子
    
    #+ATTR_REVEAL: :code_attribs data-line-numbers
    #+begin_src scala
    package org.xusheng.ioliw

    import cats.data.NonEmptyList
    import cats.effect._
    import cats.instances.list._
    import cats.syntax.all._
    import fetch._

    object sample {
      type NodeName = String

      case class Node(name: NodeName)

      case class Dep(name: NodeName, deps: List[NodeName])

      def latency[F[_] : Concurrent](msg: String): F[Unit] =
        for {
          _ <- Sync[F].delay(println(s"--> [${Thread.currentThread.getId}] $msg"))
          _ <- Sync[F].delay(Thread.sleep(1000))
          _ <- Sync[F].delay(println(s"<-- [${Thread.currentThread.getId}] $msg"))
        } yield ()

      val nodeDatabase: Map[NodeName, Node] = Map(
        "A" -> Node("A"),
        "B" -> Node("B"),
        "C" -> Node("C"),
        "D" -> Node("D"),
        "E" -> Node("E"),
        "F" -> Node("F")
      )

      object Nodes extends Data[NodeName, Node] {
        def name = "Nodes"

        def source[F[_] : ConcurrentEffect]: DataSource[F, NodeName, Node] = new DataSource[F, NodeName, Node] {
          override def data = Nodes

          override def CF = ConcurrentEffect[F]

          override def fetch(id: NodeName): F[Option[Node]] =
            latency[F](s"One Node $id") >> CF.pure(nodeDatabase.get(id))

          // override def maxBatchSize: Option[Int] = Some(2)

          override def batchExecution: BatchExecution = InParallel

          override def batch(ids: NonEmptyList[NodeName]): F[Map[NodeName, Node]] =
            latency[F](s"Batch Nodes $ids") >> CF.pure(nodeDatabase.filterKeys(ids.toList.toSet))
        }
      }

      def getNode[F[_] : ConcurrentEffect](id: NodeName): Fetch[F, Node] =
        Fetch(id, Nodes.source)

      def getGraph[F[_] : ConcurrentEffect](id: NodeName, deps: Map[NodeName, List[NodeName]]): Fetch[F, Node] =
        for {
          _ <- deps.get(id).map {
            ids => ids.traverse(i => getGraph(i, deps))
          }.getOrElse(Fetch.pure[F, List[Node]](List.empty))
          n <- getNode(id)
        } yield n

      def main(args: Array[String]): Unit = {
        import java.util.concurrent._

        import scala.concurrent.ExecutionContext
        import scala.concurrent.duration._

        val executor = new ScheduledThreadPoolExecutor(4)
        val executionContext: ExecutionContext = ExecutionContext.fromExecutor(executor)

        implicit val timer: Timer[IO] = IO.timer(executionContext)
        implicit val cs: ContextShift[IO] = IO.contextShift(executionContext)


        val deps = Map(
          "A" -> List("B", "C"),
          "B" -> List("D", "E"),
          "C" -> List("E", "F"),
        )

        Fetch.run[IO](getGraph("A", deps)).unsafeRunTimed(10.seconds)

        executor.shutdown()
      }
    }
    #+end_src

    #+begin_src text
    --> [19] Batch Nodes NonEmptyList(D, E, F)
    <-- [19] Batch Nodes NonEmptyList(D, E, F)
    --> [21] Batch Nodes NonEmptyList(B, C)
    <-- [21] Batch Nodes NonEmptyList(B, C)
    --> [19] One Node A
    <-- [19] One Node A
    #+end_src

** IO Monad in Java

*** 一个简单的实现
    
    #+begin_src java
    public class IO<T> {
        private final Supplier<T> value;

        private IO(Supplier<T> value) {
            this.value = value;
        }

        public static <T> IO<T> of(Supplier<T> value) {
            return new IO<>(value);
        }

        public static <T> IO<T> ret(T t) {
            return new IO<>(() -> t);
        }

        public static <A, B> IO<B> bind(IO<A> ma, Function<A, IO<B>> f) {
            return new IO<>(() -> f.apply(ma.value.get()).value.get());
        }
    }
    #+end_src

*** 写几个util
    
    #+begin_src java
    public static IO<Void> printf(PrintStream s, String format, Object... args) {
        return IO.of(() -> {
                s.printf(format, args);
                return null;
            });
    }

    public static IO<Void> printf(String format, Object... args) {
        return printf(System.out, format, args);
    }

    public static IO<String> readLine(InputStream s) {
        return IO.of(() -> new Scanner(s).nextLine());
    }

    public static IO<String> readLine() {
        return readLine(System.in);
    }
    #+end_src

*** 使用实例

    #+begin_src java
    public static void main(String[] args) {
        printf("What's your name? ")
            .bind(readLine()).bind(name -> printf("Hello, %s\n", name))
            .bind(printf("How old are you? "))
            .bind(readInt())
            .bind(age -> printf("You are %d years old.\n", age))
            .runIO();
    }
    #+end_src

*** 但是......

    #+begin_src java
    IO<Void> m = printf("function composition\n")
        .bind(printf("begin\n"));
    for (int i = 0; i < 10000; i++) {
        m = m.bind(IO.ret(1)).bind(IO.ret(null));
    }
    m = m.bind(printf("end\n"));
    m.runIO();
    #+end_src

    #+ATTR_REVEAL: :frag t
    #+begin_src text
    Exception in thread "main" java.lang.StackOverflowError
      at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
      at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
      at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
      at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
      at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
      at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
      at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
      at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
      at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
      at org.xusheng.ioliw.haxl.IO.lambda$bind$4(IO.java:44)
    ...
    #+end_src

*** 还记得 ~trampoline~ 吗？
    
    定义trampoline interface

    #+begin_src java
    public interface Trampoline<A> {
        default Trampoline<A> jump() {
            // TODO
        }

        default <B> Trampoline<B> flatMap(Function<A, Trampoline<B>> f) {
            // TODO
        }

        default <B> Trampoline<B> map(Function<A, B> f) {
            // TODO
        }

        default A runT() {
            // TODO
        }
    }
    #+end_src

    #+REVEAL: split

    Done

    #+begin_src java
    @AllArgsConstructor(access = AccessLevel.PRIVATE)
    class Done<A> implements Trampoline<A> {
        private final A result;
    }

    static <T> Trampoline<T> done(T t) {
        return new Done<>(t);
    }
    #+end_src

    #+REVEAL: split

    More

    #+begin_src java
    @AllArgsConstructor(access = AccessLevel.PRIVATE)
    class More<A> implements Trampoline<A> {
        private final Supplier<Trampoline<A>> k;
    }

    static <T> Trampoline<T> more(Supplier<Trampoline<T>> k) {
        return new More<>(k);
    }
    #+end_src

    #+REVEAL: split

    FlatMap

    #+begin_src java
    @AllArgsConstructor(access = AccessLevel.PRIVATE)
    class FlatMap<B, A> implements Trampoline<A> {
        private final Trampoline<B> sub;
        private final Function<B, Trampoline<A>> k;
    }

    static <B, A> Trampoline<A> flatMap(Trampoline<B> sub,
                                        Function<B, Trampoline<A>> k) {
        return new FlatMap<>(sub, k);
    }
    #+end_src

    #+REVEAL: split

    let's jump

    #+ATTR_REVEAL: :frag fade-out
    #+begin_src java
    default Trampoline<A> jump() {
        if (this instanceof Done) {
            return this;
        }
        if (this instanceof More) {
            return ((More<A>) this).k.get();
        }
    #+end_src

    #+ATTR_REVEAL: :frag t
    #+begin_src java
        if (this instanceof FlatMap) {
            Trampoline<Object> a = ((FlatMap<Object, A>) this).sub;
            Function<Object, Trampoline<A>> f = ((FlatMap<Object, A>) this).k;
            if (a instanceof Done) {
                return f.apply(((Done<Object>) a).result);
            }
            if (a instanceof More) {
                return new FlatMap<>(((More<Object>) a).k.get(), f);
            }
            if (a instanceof FlatMap) {
                Trampoline<Object> b = ((FlatMap<Object, Object>) a).sub;
                Function<Object, Trampoline<Object>> g =
                    ((FlatMap<Object, Object>) a).k;
                return new FlatMap<>(b, x -> new FlatMap<>(g.apply(x), f));
            }
            throw new RuntimeException("unhandled sub type " + a.getClass());
        }
        throw new RuntimeException("unhandled type " + this.getClass());
    }
    #+end_src

    #+REVEAL: split

    flatMap & map
    
    #+begin_src java
    default <B> Trampoline<B> flatMap(Function<A, Trampoline<B>> f) {
        return new FlatMap<>(this, f);
    }
    #+end_src

    #+begin_src java
    default <B> Trampoline<B> map(Function<A, B> f) {
        return new FlatMap<>(this, a -> done(f.apply(a)));
    }
    #+end_src

    #+REVEAL: split
    
    run!!
    
    #+begin_src java
    default A runT() {
        Trampoline<A> t = this;
        while (!(t instanceof Done)) {
            t = t.jump();
        }
        return ((Done<A>) t).result;
    }
    #+end_src

    #+REVEAL: split

    实例

    #+begin_src java
    public static void main(String[] args) {
        more(() -> {
                System.out.print("What's your name? ");
                return done(null);
            })
            .flatMap(v -> done(new Scanner(System.in).nextLine()))
            .flatMap(name -> {
                    System.out.printf("Hello, %s!\n", name);
                    return done(null);
                })
            .runT();
    }
    #+end_src

*** 使用Trampoline优化IO
    
    #+begin_src java
    public class IO<T> {
        private final Trampoline<T> value;

        private IO(Trampoline<T> value) {
            this.value = value;
        }

        private IO(Supplier<T> value) {
            this(more(() -> done(value.get())));
        }

        public static <T> IO<T> ret(T t) {
            return pure(t);
        }

        public static <T> IO<T> pure(T t) {
            return new IO<>(() -> t);
        }

        public static <A, B> IO<B> fmap(Function<A, B> f, IO<A> fa) {
            return new IO<>(fa.value.map(f));
        }

        public static <A, B> IO<B> bind(IO<A> ma, Function<A, IO<B>> func) {
            return new IO<>(ma.value.flatMap(x -> func.apply(x).value));
        }
        // ...
    }
    #+end_src

*** 再试一次

    #+begin_src java
    public static void main(String[] args) {
        IO<Void> m = printf("trampoline\n")
            .bind(printf("begin\n"));
        for (int i = 0; i < 10000; i++) {
            m = m.bind(IO.ret(0)).bind(IO.ret(null));
        }
        m = m.bind(printf("end\n"));
        m.runIO();
    }
    #+end_src

    #+ATTR_REVEAL: :frag t    
    #+begin_src text
    trampoline
    begin
    end
    #+end_src

** Haxl in Java???
   
*** Haxl的原理
    
    Concurrency monads A
    #+begin_src haskell
    data Fetch a = Done a | Blocked (Fetch a) An
    #+end_src

    #+ATTR_REVEAL: :frag fade-in-then-out
    #+begin_src haskell
    class Functor f where
      fmap :: (a -> b) -> f a -> f b

    class Functor f => Applicative f where
      pure :: a -> f a
      (<*>) :: f (a -> b) -> f a -> f b

    class Monad f where
      return :: a -> f a
      (>>=) :: f a -> (a -> f b) -> f b

    ap :: (Monad m) => m (a -> b) -> m a -> m b
    ap mf mx = do
      f <- mf
      x <- mx
      return (f x)
    #+end_src

    #+ATTR_REVEAL: :frag t
    #+begin_src haskell
    instance Functor Fetch where
      fmap f (Done x) = Done (f x)
      fmap f (Blocked c) = Blocked (fmap f c)

    instance Monad Fetch where
      return = Done

      Done a >>= k = k a
      Blocked c >>= k = Blocked (c >>= k)
    #+end_src

    #+REVEAL: split

    Applicative concurrency

    #+ATTR_REVEAL: :frag fade-in-then-out
    #+begin_src haskell
    instance Applicative Fetch where
      pure = return

      Done g <*> Done y = Done (g y)
      Done g <*> Blocked c = Blocked (g <$> c) -- <$> = fmap
      Blocked c <*> Done y = Blcoked (c <*> Done y)
      Blocked c <*> Blocked d = Blocked (c <*> d)
    #+end_src

    #+ATTR_REVEAL: :frag t
    #+begin_src haskell
    instance Applicative Fetch where
      pure = return

      Done f <*> x = f <$> x
      Blocked c <*> x = Blocked (c <*> x)
    #+end_src

    #+REVEAL: split

    Fetching data

    #+begin_src haskell
    newIORef :: a -> IO (IORef a)
    readIORef :: IORef a -> IO a
    writeIORef :: IORef a -> a -> IO ()

    data BlockedRequest =
      forall a . BlockedRequest (Request a) (IORef (FetchStatus a))

    data FetchStatus a
      = NotFetched
      | FetchSuccess a
    #+end_src

    #+begin_src haskell
    data Result a
      = Done a
      | Blocked (Seq BlockedRequest) (Fetch a)

    newtype Fetch a = Fetch { unFetch :: IO (Result a) }
    #+end_src

    #+REVEAL: split

    #+begin_src haskell
    instance Applicative Fetch where
      pure = return
      Fetch f <*> Fetch x = Fetch $ do
        f' <- f
        x' <- x
        case (f', x') of
          (Done g, Done y ) -> return (Done (g y))
          (Done g, Blocked br c ) -> return (Blocked br (g <$> c))
          (Blocked br c, Done y ) -> return (Blocked br (c <*> return y))
          (Blocked br1 c, Blocked br2 d) -> return (Blocked (br1 <> br2) (c <*> d))
    #+end_src

    #+begin_src haskell
    instance Monad Fetch where
      return a = Fetch $ return (Done a)

      Fetch m >>= k = Fetch $ do
        r <- m
        case r of
          Done a -> unFetch (k a)
          Blocked br c -> return (Blocked br (c >>= k))
    #+end_src

    #+REVEAL: split

    #+begin_src haskell
    dataFetch :: Request a -> Fetch a
    dataFetch request = Fetch $ do
      box ← newIORef NotFetched             -- (1)
      let br = BlockedRequest request box   -- (2)
      let cont = Fetch $ do                 -- (3)
            FetchSuccess a <- readIORef box -- (4)
            return (Done a)                 -- (5)
      return (Blocked (singleton br) cont)  -- (6)
    #+end_src
    
    #+ATTR_REVEAL: :frag (appear)
    - Line 1 creates a new ~IORef~ to store the result, initially containing NotFetched.
    - Line 2 creates a ~BlockedRequest~ for this request. 
    - Lines 3–5 define the continuation, which reads the result from the ~IORef~ and returns it in the monad. Note that the contents of the IORef is assumed to be ~FetchSuccess a~ when the continuation is executed. It is an internal error of the framework if this is not true, so we don't attempt to handle the error condition here.
    - Line 6: ~dataFetch~ returns ~Blocked~ in the monad, including the ~BlockedRequest~.

    #+REVEAL: split

    Running a computation

    #+begin_src haskell
    fetch :: [BlockedRequest] -> IO ()
    fetch = undefined

    runFetch :: Fetch a -> IO a
    runFetch (Fetch h) = do
      r <- h
      case r of
        Done a -> return a
        Blocked br cont -> do
          fetch (toList br)
          runFetch cont
    #+end_src

*** Java实现

    #+ATTR_REVEAL: :frag (appear)
    1. Haxl的原理
    2. 基于Trampoline的IO Monad实现
    3. 可以实现IORef
    4. Trampoline可以用于其他Monad的实现

    #+REVEAL: split

    [[https://github.com/shanexu/if-our-language-is-whiskey/tree/master/src/main/java/org/xusheng/ioliw/haxl]]

* 参考文档

  1. Why Functional Programming Matters\\
     [[https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf]]
  2. All About Monads\\
     [[https://wiki.haskell.org/All_About_Monads]]
  3. Stackless Scala With Free Monads\\
     [[http://blog.higher-order.com/assets/trampolines.pdf]]
  4. There is no Fork: an Abstraction for Efficient, Concurrent, and Concise Data Access\\
     [[http://simonmar.github.io/bib/papers/haxl-icfp14.pdf]]
  5. Real World Haskell\\
     [[http://book.realworldhaskell.org/read/]]
  6. Category Theory for Programmers\\
     [[https://github.com/hmemcpy/milewski-ctfp-pdf]]

* 关于标题
  
  《如果我们的语言是威士忌》是村上春树的游记，他的文字带着我们走上他独特视线的异国之旅。那异国的风土人情，远方香醇的威士忌，在他的笔下缓缓流出，流入读者心中，沁人心脾。

  [[./imgs/cover.jpg]]

* 仓库地址

  [[https://github.com/shanexu/if-our-language-is-whiskey]]

* Q & A

* THANKS
